<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogReel Pro</title>
    <style>
        :root {
            --primary-color: #3B82F6; /* A slightly softer, modern blue */
            --primary-color-dark: #2563EB;
            --secondary-color: #10B981; /* A vibrant teal/green for accents */
            --text-color: #1F2937; /* Dark gray for text */
            --text-color-light: #4B5563;
            --text-color-very-light: #6B7280;
            --bg-color: #F3F4F6; /* Light gray background */
            --card-bg-color: #FFFFFF;
            --border-color: #D1D5DB; /* Lighter border color */
            --danger-color: #EF4444;
            --warning-color: #F59E0B; /* Amber for stars/warnings */
            --success-color: #10B981; /* Same as secondary, good for success */
            --info-color: #3B82F6; /* Same as primary for info */
            
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --border-radius: 8px; /* Slightly larger, more modern radius */
            --border-radius-small: 4px;
            --box-shadow: 0 4px 6px -1px rgba(0,0,0,0.07), 0 2px 4px -2px rgba(0,0,0,0.05); /* Softer shadow */
            --box-shadow-light: 0 1px 3px 0 rgba(0,0,0,0.07), 0 1px 2px -1px rgba(0,0,0,0.05);
            --box-shadow-strong: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1);

            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 100%; /* Base font size */
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-size: 0.9375rem; /* 15px for base text on mobile */
        }

        .container {
            width: 100%;
            margin: 0 auto;
            padding: var(--space-md);
        }
        
        /* Screens */
        .screen { display: none; }
        .screen.active { display: block; }

        /* Headers */
        .app-header {
            background-color: var(--card-bg-color);
            color: var(--text-color);
            padding: var(--space-md) var(--space-lg);
            text-align: center;
            margin-bottom: var(--space-lg);
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--box-shadow-light);
        }
        .app-header h1 {
            font-size: 1.5em; /* 24px */
            font-weight: 700;
            color: var(--primary-color);
        }

        .header-with-back {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            background-color: var(--card-bg-color);
            color: var(--text-color);
            padding: var(--space-sm) var(--space-md);
            margin-bottom: var(--space-lg);
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--box-shadow-light);
            position: sticky;
            top: 0;
            z-index: 900;
        }
        .header-with-back .back-button {
            grid-column: 1 / 2;
            background: none;
            border: none;
            color: var(--text-color-light);
            font-size: 1.75em; /* Larger tap target */
            cursor: pointer;
            padding: var(--space-sm) var(--space-md) var(--space-sm) var(--space-sm);
            font-weight: 500;
            line-height: 1;
            transition: color 0.2s ease;
        }
        .header-with-back .back-button:hover,
        .header-with-back .back-button:focus { 
            color: var(--primary-color); 
            outline: none;
        }
        .header-with-back h2 {
            grid-column: 2 / 3;
            font-size: 1.25em; /* 20px */
            font-weight: 600;
            margin: 0;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .header-spacer-right {
            grid-column: 3 / 4;
            visibility: hidden; /* Takes up space but not visible */
            /* width will be set by JS to match back button */
        }


        /* Buttons */
        .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75em 1.25em; /* Relative padding */
            font-size: 0.9375rem; /* 15px */
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            text-decoration: none;
            border: 1px solid transparent;
            border-radius: var(--border-radius);
            transition: all 0.2s ease-in-out;
            white-space: nowrap;
        }
        .button:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }
        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .button-primary {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        .button-primary:hover:not(:disabled) {
            background-color: var(--primary-color-dark);
            border-color: var(--primary-color-dark);
            box-shadow: 0 2px 8px rgba(0,0,0, 0.1);
        }
        .button-secondary {
            background-color: var(--card-bg-color);
            color: var(--primary-color);
            border-color: var(--primary-color);
        }
        .button-secondary:hover:not(:disabled) {
            background-color: var(--bg-color); /* Light gray tint */
            border-color: var(--primary-color-dark);
            color: var(--primary-color-dark);
        }
        .button-danger {
            background-color: var(--danger-color);
            color: white;
            border-color: var(--danger-color);
        }
        .button-danger:hover:not(:disabled) {
            background-color: #CC2525; /* Darker red */
            border-color: #CC2525;
        }
        .button-subtle {
            background-color: transparent;
            color: var(--text-color-light);
            border-color: var(--border-color);
        }
        .button-subtle:hover:not(:disabled) {
            background-color: #E5E7EB; /* Lighter gray for subtle hover */
            color: var(--text-color);
            border-color: #9CA3AF;
        }
        .button-full-width { display: flex; width: 100%; margin-bottom: var(--space-sm); }
        .button-small { padding: 0.5em 0.875em; font-size: 0.8125rem; /* 13px */ }
        .button-icon { margin-right: var(--space-sm); font-size: 1.1em; }
        .button .button-icon-only { margin-right: 0; }

        /* Cards */
        article.card, article.video-entry-card, article.log-item {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--space-md);
            margin-bottom: var(--space-lg);
            box-shadow: var(--box-shadow);
        }
        .card-title {
            font-size: 1.25em; /* 20px */
            font-weight: 600;
            margin-bottom: var(--space-sm);
            color: var(--text-color);
        }
        .card-meta {
            font-size: 0.875em; /* 14px */
            color: var(--text-color-light);
            margin-bottom: var(--space-md);
        }
        .card-actions {
            margin-top: var(--space-md);
            display: flex;
            gap: var(--space-sm);
            flex-direction: column; /* Mobile first: stack buttons */
        }
        .card-actions .button { flex-grow: 1; } /* Buttons take full width in column */


        /* Forms */
        .form-group { margin-bottom: var(--space-md); }
        .form-group label {
            display: block;
            margin-bottom: var(--space-sm);
            font-weight: 500;
            font-size: 0.875em; /* 14px */
            color: var(--text-color-light);
        }
        .form-group input[type="text"],
        .form-group input[type="search"],
        .form-group textarea {
            width: 100%;
            padding: 0.75em 1em;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-small);
            font-size: 1rem; /* 16px to avoid iOS zoom */
            font-family: var(--font-family);
            transition: border-color 0.2s, box-shadow 0.2s;
            background-color: var(--card-bg-color);
            color: var(--text-color);
        }
        .form-group input[type="text"]:focus,
        .form-group input[type="search"]:focus,
        .form-group textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); /* primary-color with alpha */
            outline: none;
        }
        .form-group textarea { min-height: 120px; resize: vertical; }
        
        input[type="search"] {
            padding: 0.75em 1em;
            font-size: 1rem; /* 16px to avoid iOS zoom */
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-small);
            width: 100%;
            margin-bottom: var(--space-lg);
        }
        input[type="search"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            outline: none;
        }

        /* Modals */
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto; 
            background-color: rgba(17, 24, 39, 0.6); /* Darker backdrop color (text-color related) */
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            padding: var(--space-md); /* Padding for mobile view to not touch edges */
        }
        .modal-content {
            background-color: var(--card-bg-color); 
            margin: auto; /* Vertically and horizontally center */
            padding: var(--space-lg);
            border-radius: var(--border-radius); 
            width: 100%; 
            max-width: 500px;
            box-shadow: var(--box-shadow-strong); 
            animation: modalOpen 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: relative; /* For centering, works with margin:auto on flex container */
        }
        .modal { /* Use flex to center modal-content */
            display: none; /* Keep initial state */
            align-items: center;
            justify-content: center;
        }
        @keyframes modalOpen { 
            from { opacity: 0; transform: scale(0.95) translateY(10px); } 
            to { opacity: 1; transform: scale(1) translateY(0); } 
        }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding-bottom: var(--space-md); 
            border-bottom: 1px solid var(--border-color); 
            margin-bottom: var(--space-lg);
        }
        .modal-title { font-size: 1.375em; /* 22px */ font-weight: 600; }
        .close-button {
            color: var(--text-color-very-light); font-size: 2em; font-weight: normal;
            cursor: pointer; background: none; border: none; padding: 0; line-height: 1;
            transition: color 0.2s ease;
        }
        .close-button:hover, .close-button:focus { 
            color: var(--text-color); 
            outline: none;
        }

        /* Toast Notifications */
        #toast-container {
            position: fixed;
            bottom: var(--space-lg);
            right: var(--space-lg);
            left: var(--space-lg); /* Allow toasts to use full width on mobile */
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
            max-width: calc(100% - var(--space-lg) * 2); 
        }
        .toast-message {
            padding: var(--space-md);
            background-color: var(--text-color);
            color: white;
            border-radius: var(--border-radius-small);
            box-shadow: var(--box-shadow-strong);
            font-size: 0.9375rem; /* 15px */
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            word-break: break-word; /* Ensure long messages wrap */
        }
        .toast-message.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        .toast-message.error { background-color: var(--danger-color); }
        .toast-message.success { background-color: var(--success-color); }
        .toast-message.warning { background-color: var(--warning-color); color: var(--text-color); }
        .toast-message.info { background-color: var(--info-color); }


        /* General UI Elements */
        .actions-bar {
            margin-bottom: var(--space-lg);
            display: flex;
            flex-direction: column; /* Stack buttons on mobile */
            gap: var(--space-md);
        }

        .section-title {
            font-size: 1.125em; /* 18px */ 
            font-weight: 600; 
            margin-top: var(--space-xl);
            margin-bottom: var(--space-md); 
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid var(--border-color); 
            color: var(--text-color);
        }
        .empty-state {
            text-align: center; padding: var(--space-xl) var(--space-lg);
            color: var(--text-color-light); border: 2px dashed var(--border-color);
            border-radius: var(--border-radius); margin-top: var(--space-lg);
            background-color: #f9fafb; /* Slightly different background for emphasis */
        }
        .empty-state p { font-size: 1.05em; margin-bottom: var(--space-md); }
        .empty-state p:last-child { margin-bottom: 0; }


        /* Screen 2: Project Videos */
        .video-entry-header {
            padding: var(--space-md);
            display: flex;
            flex-direction: column; /* Stack elements on mobile */
            align-items: flex-start;
            border-bottom: 1px solid var(--border-color);
            gap: var(--space-md);
        }
        .video-entry-title {
            font-size: 1.125em; /* 18px */
            font-weight: 600;
            color: var(--text-color);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: normal; /* Allow wrap on mobile */
            width: 100%;
            word-break: break-all; /* For very long filenames without spaces */
        }
        .video-card-number {
            font-weight: normal;
            color: var(--text-color-light);
            margin-right: var(--space-xs);
        }
        .video-entry-actions {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            width: 100%;
            justify-content: space-between; /* Space out buttons */
        }
        .video-entry-actions .button { 
            flex-grow: 1; /* Make buttons share space, or define fixed widths */
            padding-left: var(--space-sm); padding-right: var(--space-sm); /* Adjust padding for smaller buttons */
        }
        .btn-toggle-important {
            padding: 0.5em !important; /* Make it more like an icon button */
            min-width: auto;
            flex-grow: 0 !important;
        }
        .btn-toggle-important .button-icon {
            font-size: 1.5em; 
            margin-right: 0; 
        }
        .btn-toggle-important.is-important .button-icon {
            color: var(--warning-color);
        }

        .inline-clip-player-area {
            background-color: #000;
            position: relative;
            min-height: 180px; /* Adjust for mobile */
            display: none; 
            border-radius: var(--border-radius-small);
            overflow: hidden;
            margin-top: var(--space-md);
        }
        .inline-clip-player-area.active { display: block; }
        .inline-clip-player-area video { width: 100%; display: block; max-height: 300px; }
        .inline-clip-player-prompt {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background-color: rgba(0,0,0,0.9); color: white; padding: var(--space-lg); text-align: center;
        }
        .inline-clip-player-prompt p { margin-bottom: var(--space-md); font-size: 0.9375rem; line-height: 1.5; }
        .inline-clip-player-prompt strong { color: var(--secondary-color); }
        .inline-clip-player-prompt label { font-size: 0.875rem; }

        .video-clips-list-container { padding: var(--space-md) 0; } /* Remove side padding, parent card has it */
        .video-clips-list-container h4 {
            font-size: 1em; /* 16px */ 
            font-weight: 500; 
            color: var(--text-color-light);
            margin-bottom: var(--space-md);
            padding-left: var(--space-xs); /* Align with items if they have padding */
        }
        .clip-item-card {
            display: flex;
            flex-direction: column; /* Stack on mobile */
            gap: var(--space-sm);
            padding: var(--space-md);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-small);
            margin-bottom: var(--space-md);
            background-color: #fcfcfc;
        }
        .clip-item-thumbnail {
            width: 100%; height: auto;
            max-height: 160px; /* Limit height */
            background-color: var(--border-color); object-fit: cover;
            border-radius: var(--border-radius-small); 
            margin-bottom: var(--space-sm);
            aspect-ratio: 16 / 9; /* Maintain aspect ratio */
        }
        .clip-item-info { flex-grow: 1; min-width:0; }
        .clip-item-info .notes { font-size: 1em; margin-bottom: var(--space-xs); font-weight: 500; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; word-break: break-word; }
        .clip-item-info .time, .clip-item-info .keywords, .clip-item-info .rating {
            font-size: 0.8125rem; /* 13px */ 
            color: var(--text-color-very-light); margin-bottom: var(--space-xs);
        }
        .clip-item-actions { 
            display: flex; 
            gap: var(--space-sm); 
            width: 100%; 
            margin-top: var(--space-sm);
        }
        .clip-item-actions .button-small { 
            flex-grow: 1; 
            padding: 0.6em 0.8em; 
            font-size: 0.8125rem; 
        }

        /* Screen 3: Video Logging */
        #video-player-container {
            width: 100%; background-color: black; margin-bottom: var(--space-md);
            position: relative; border-radius: var(--border-radius); overflow:hidden;
            box-shadow: var(--box-shadow);
        }
        #video-player { width: 100%; display: block; max-height: 45vh;} /* Limit height on mobile */
        #video-file-prompt {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.9); color: white; padding: var(--space-lg); text-align: center;
            border-radius: var(--border-radius); z-index:10;
        }
        #video-file-prompt p { margin-bottom: var(--space-md); line-height: 1.5; font-size: 0.9375rem;}
        #video-file-prompt strong { color: var(--secondary-color); }
        
        .video-controls {
            display: flex; 
            flex-direction: column; /* Stack on mobile */
            gap: var(--space-sm); 
            align-items: stretch; /* Full width items */
            margin-bottom: var(--space-lg); 
            padding: var(--space-md);
            background-color: var(--card-bg-color); border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow-light);
        }
        .video-controls .button, .video-controls select, .video-controls div { 
            width: 100%; text-align: center; 
        }
        .video-controls select { /* Style select like a button */
            padding: 0.75em 1.25em;
            font-size: 0.9375rem;
            font-weight: 500;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--card-bg-color);
            color: var(--text-color-light);
            appearance: none; /* Remove default arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%236B7280'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd' /%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75em center;
            background-size: 1.25em;
        }


        #timeline-container {
            width: 100%; height: 10px; background-color: #E5E7EB; cursor: pointer;
            border-radius: var(--border-radius-small); margin-bottom: var(--space-sm); overflow: hidden;
        }
        #timeline-progress { height: 100%; background-color: var(--primary-color); border-radius: var(--border-radius-small); }
        .timecode-display { 
            font-family: monospace; font-size: 0.9375rem; 
            color: var(--text-color-light); 
            padding: var(--space-sm) 0;
            text-align: center;
        }
        .mark-buttons { display: flex; flex-direction: column; gap: var(--space-sm); margin-bottom: var(--space-lg); }
        .mark-buttons .button { flex-grow: 1; }
        
        .star-rating { display: flex; gap: var(--space-sm); cursor: pointer; margin-bottom: var(--space-sm); justify-content: center; }
        .star-rating .star {
            background: none; border: none; padding: 0;
            font-size: 2.25em; /* Larger stars */ 
            color: var(--border-color); line-height: 1;
            cursor: pointer; transition: color 0.1s ease, transform 0.1s ease;
        }
        .star-rating .star:hover { transform: scale(1.1); }
        .star-rating .star.selected, .star-rating .star:hover, .star-rating .star:focus { 
            color: var(--warning-color); 
            outline: none;
        }
        .star-rating .star:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }
        
        article.log-item { padding: var(--space-md); } /* Already defined, ensure padding is consistent */
        .log-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm); }
        .log-item-time { font-weight: 600; font-size: 1em; }
        .log-item-notes { margin-bottom: var(--space-sm); font-size:0.9375rem; color: var(--text-color-light); word-break: break-word; }
        .log-item-keywords { font-style: italic; font-size: 0.875rem; color: var(--text-color-very-light); margin-bottom: var(--space-sm); word-break: break-all; }
        .log-item-rating .star { font-size: 0.8em; } 
        .log-item img { 
            max-width:120px; 
            max-height:75px; 
            border-radius:var(--border-radius-small); 
            margin-top:var(--space-sm); 
            border:1px solid var(--border-color); 
            object-fit: cover;
        }


        /* File input styling */
        .file-input-label { /* General label for file inputs that looks like a button */
            display: inline-flex; align-items: center; justify-content: center;
            padding: 0.75em 1.25em; font-size: 0.9375rem; font-weight: 500;
            cursor: pointer; text-align: center; text-decoration: none;
            border: 1px solid var(--primary-color); border-radius: var(--border-radius);
            background-color: var(--primary-color); color: white;
            transition: all 0.2s ease-in-out;
        }
        .file-input-label:hover {
            background-color: var(--primary-color-dark); border-color: var(--primary-color-dark);
        }
        input[type="file"] { display: none; } /* Kept, but sr-only is better */
        
        .hidden { display: none !important; }
        .sr-only { 
            position: absolute; width: 1px; height: 1px; padding: 0; 
            margin: -1px; overflow: hidden; clip: rect(0,0,0,0); 
            white-space: nowrap; border: 0; 
        }

        /* Utility classes */
        .mt-1 { margin-top: var(--space-sm); }
        .mb-1 { margin-bottom: var(--space-sm); }

        /* Responsive adjustments for larger screens */
        @media (min-width: 600px) { /* Tablet and above */
            body { font-size: 1rem; /* 16px */ }
            .container { 
                max-width: 900px;
                padding: var(--space-lg) var(--space-xl); 
            }
            .app-header h1 { font-size: 1.75em; } /* 28px */
            .header-with-back { padding: var(--space-md) var(--space-lg); }
            .header-with-back h2 { font-size: 1.4em; } /* 22px */
            
            .actions-bar {
                flex-direction: row; /* Buttons side-by-side */
                justify-content: flex-start; /* Align to start */
            }
            .actions-bar .button { width: auto; /* Buttons take their content size */ }

            .card-actions {
                flex-direction: row; /* Buttons side-by-side */
            }
             .card-actions .button {
                flex-grow: 0; /* Don't grow to fill, take natural width unless specified */
            }
            .card-actions .button:first-child { /* Often the primary action */
                flex-grow: 1; /* Allow primary action to take more space if needed */
            }
             @media (min-width: 768px) { /* Slightly larger breakpoint for card actions */
                .card-actions .button:first-child {
                    flex-grow: 0;
                }
            }


            .video-entry-header {
                flex-direction: row; /* Side-by-side layout */
                justify-content: space-between;
                align-items: center;
            }
            .video-entry-title {
                white-space: nowrap; /* Prevent wrap on desktop */
                width: auto;
                flex-grow: 1;
            }
            .video-entry-actions {
                width: auto; /* Natural width */
                justify-content: flex-end; /* Align to end */
            }
             .video-entry-actions .button {
                flex-grow: 0; /* Natural width */
            }

            .clip-item-card {
                flex-direction: row; /* Side-by-side on desktop */
                align-items: center;
            }
            .clip-item-thumbnail {
                width: 100px; height: 60px; /* Fixed size on desktop */
                margin-bottom: 0;
                flex-shrink: 0;
                aspect-ratio: auto; /* remove aspect ratio if fixed dimensions */
            }
            .clip-item-actions {
                flex-direction: column; /* Stack actions vertically beside info */
                align-items: flex-end;
                width: auto; /* Natural width */
                margin-top: 0;
            }
             .clip-item-actions .button-small {
                flex-grow: 0; /* Natural width */
                width: 100%;
                text-align: right;
            }
            .clip-item-actions .button-small + .button-small {
                 margin-left: 0;
            }

            .video-controls {
                flex-direction: row; /* Side-by-side */
                align-items: center;
            }
            .video-controls .button, .video-controls select, .video-controls div { 
                width: auto; /* Natural width */
            }
            .video-controls > *:not(:last-child) {
                margin-right: var(--space-sm);
            }
            .timecode-display { min-width: 170px; text-align: left; }

            .mark-buttons { 
                flex-direction: row; 
            }

            #toast-container { /* Toasts on desktop can be less wide */
                left: auto; /* Remove left constraint */
                max-width: 380px;
                bottom: var(--space-xl);
                right: var(--space-xl);
            }
        }

        @media (min-width: 900px) { /* Larger desktop */
             .container {
                padding: var(--space-xl) var(--space-lg); 
             }
            /* Example: Maybe 2-column layout for project cards if many */
            /* #projects-list {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
                gap: var(--space-lg);
            } */
            article.card, article.video-entry-card, article.log-item {
                 padding: var(--space-lg);
            }
            #video-player { max-height: 60vh;}
        }

    </style>
</head>
<body>
    <!-- App Container -->
    <div id="app-container">
        <!-- Screen 1: Projects List -->
        <div id="screen-projects" class="screen">
            <header class="app-header">
                <h1>LogReel Pro</h1>
            </header>
            <div class="container">
                <div class="actions-bar">
                    <button id="btn-new-project" class="button button-primary">
                        <span class="button-icon">&#43;</span> New Project
                    </button>
                    <label class="button button-secondary">
                        <span class="button-icon">&#x1F4E5;</span> Import Projects
                        <input type="file" id="import-projects-input" accept=".json" class="sr-only">
                    </label>
                </div>
                <div id="projects-list" aria-live="polite" aria-atomic="true">
                    <!-- Project cards will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Screen 2: Project Videos -->
        <div id="screen-project-videos" class="screen">
            <header class="header-with-back">
                <button id="btn-back-to-projects" class="back-button" aria-label="Back to projects list">&#x2190;</button>
                <h2 id="project-name-header">Project Name</h2>
                <div class="header-spacer-right" id="project-videos-header-spacer"></div>
            </header>
            <div class="container">
                <div class="actions-bar">
                    <!-- Add Videos button/label will be dynamically created based on FS API support -->
                    <div id="add-videos-action-container"></div>
                    
                    <button id="btn-export-project" class="button button-secondary">
                        <span class="button-icon">&#x1F4E4;</span> Export Project
                    </button>
                </div>
                <input type="search" id="project-videos-search" placeholder="Search videos or clips by name, notes, tags..." aria-label="Search videos and clips">
                
                <div id="project-videos-container" aria-live="polite" aria-atomic="true">
                    <!-- Video Entry Cards will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Screen 3: Video Logging -->
        <div id="screen-video-logging" class="screen">
            <header class="header-with-back">
                <button id="btn-back-to-project-videos" class="back-button" aria-label="Back to project videos">&#x2190;</button>
                <h2 id="video-filename-header">Video Filename</h2>
                <div class="header-spacer-right" id="video-logging-header-spacer"></div>
            </header>
            <div class="container">
                <div id="video-player-container">
                    <video id="video-player" playsinline controls></video>
                     <div id="video-file-prompt" class="hidden"> 
                        <p id="video-file-prompt-message">Please select the video file.</p>
                        <!-- Fallback file input, label created dynamically -->
                        <div id="video-file-input-logging-container"></div>
                    </div>
                </div>

                <div id="timeline-container" class="mb-1" aria-label="Video timeline"><div id="timeline-progress"></div></div>
                <div class="video-controls">
                    <button id="play-pause-btn" class="button button-subtle" aria-label="Play or Pause video"><span class="button-icon">&#9658;</span>Play</button> <!-- Play icon -->
                    <div id="timecode-display" class="timecode-display" aria-live="off">00:00 / 00:00</div>
                    <label for="speed-select" class="sr-only">Playback Speed:</label>
                    <select id="speed-select" aria-label="Playback speed">
                        <option value="0.5">0.5x</option>
                        <option value="1" selected>1x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                    </select>
                </div>

                <div class="mark-buttons">
                    <button id="mark-in-btn" class="button button-secondary">Mark In (00:00.0)</button>
                    <button id="mark-out-btn" class="button button-secondary">Mark Out (00:00.0)</button>
                </div>

                <article class="card"> <!-- Log Entry Form Card -->
                    <h3 class="card-title">Log Entry</h3>
                    <div class="form-group">
                        <label for="log-notes">Notes:</label>
                        <textarea id="log-notes" rows="4"></textarea>
                    </div>
                    <div class="form-group">
                        <label id="rating-label">Rating:</label>
                        <div id="log-rating" class="star-rating" role="group" aria-labelledby="rating-label">
                            <button type="button" class="star" data-value="1" aria-label="Rate 1 star" aria-pressed="false">&#9733;</button>
                            <button type="button" class="star" data-value="2" aria-label="Rate 2 stars" aria-pressed="false">&#9733;</button>
                            <button type="button" class="star" data-value="3" aria-label="Rate 3 stars" aria-pressed="false">&#9733;</button>
                            <button type="button" class="star" data-value="4" aria-label="Rate 4 stars" aria-pressed="false">&#9733;</button>
                            <button type="button" class="star" data-value="5" aria-label="Rate 5 stars" aria-pressed="false">&#9733;</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="log-keywords">Keywords (comma-separated):</label>
                        <input type="text" id="log-keywords">
                    </div>
                    <button id="save-log-btn" class="button button-primary button-full-width">Save Log</button>
                    <input type="hidden" id="editing-log-id"> 
                </article>

                <h3 class="section-title mt-2">Saved Logs for this Video</h3>
                <div id="saved-logs-list" aria-live="polite" aria-atomic="true">
                    <!-- Saved logs will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Modals -->
        <div id="modal-new-project" class="modal" role="dialog" aria-labelledby="modal-new-project-title" aria-modal="true">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="modal-title" id="modal-new-project-title">Create New Project</h3>
                    <button class="close-button" data-modal-id="modal-new-project" aria-label="Close new project dialog">&times;</button>
                </div>
                <div class="form-group">
                    <label for="new-project-name">Project Name:</label>
                    <input type="text" id="new-project-name">
                </div>
                <button id="btn-create-project-confirm" class="button button-primary button-full-width">Create Project</button>
            </div>
        </div>

        <div id="modal-confirm-action" class="modal" role="dialog" aria-labelledby="modal-confirm-action-title" aria-modal="true">
            <div class="modal-content">
                 <div class="modal-header">
                    <h3 class="modal-title" id="modal-confirm-action-title">Confirm Action</h3>
                    <button class="close-button" data-modal-id="modal-confirm-action" aria-label="Close confirmation dialog">&times;</button>
                </div>
                <p id="confirm-action-message" style="margin-bottom: var(--space-lg); font-size: 1.05em; line-height: 1.5;">Are you sure?</p>
                <div class="card-actions" style="margin-top:0;"> <!-- Using card-actions for consistent button layout -->
                    <button id="btn-confirm-action-cancel" class="button button-subtle">Cancel</button>
                    <button id="btn-confirm-action-confirm" class="button button-danger">Confirm</button>
                </div>
            </div>
        </div>

        <!-- Hidden canvas for thumbnail generation -->
        <canvas id="thumbnail-canvas" style="display:none;"></canvas>
        <!-- Toast notifications container -->
        <div id="toast-container" aria-live="assertive" aria-atomic="true"></div>
    </div>

    <script>
    const app = {
        DB_NAME: 'LogReelDB',
        DB_VERSION: 1,
        STORE_HANDLES: 'fileHandles',
        fsApiSupported: false,
        db: null, // For IndexedDB instance
        currentScreen: null, // Track current active screen

        data: {
            projects: [],
            currentProjectId: null,
            currentVideoId: null, 
            videoElement: null,
            timelineProgress: null,
            timelineContainer: null,
            playPauseBtn: null,
            timecodeDisplay: null,
            speedSelect: null,
            markInBtn: null,
            markOutBtn: null,
            markInTime: 0,
            markOutTime: null,
            currentRating: 0,
            videoFileCache: {}, // filename (string) -> objectURL (string)
            activeInlinePlayer: { 
                videoId: null,
                playerElement: null,
                promptElement: null,
                fileInputElement: null, 
                pendingLogIdToPlay: null 
            },
            previouslyFocusedElement: null,
        },
        dom: {}, 
        utils: {
            generateId() { 
                return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
            },
            formatTime(seconds, includeMillis = false) { 
                if (isNaN(seconds) || seconds < 0) return includeMillis ? '00:00.0' : '00:00';
                const h = Math.floor(seconds / 3600); const m = Math.floor((seconds % 3600) / 60);
                const s = Math.floor(seconds % 60); const ms = Math.floor((seconds - Math.floor(seconds)) * 10); 
                let timeStr = ''; if (h > 0) timeStr += `${String(h).padStart(2, '0')}:`;
                timeStr += `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
                if (includeMillis) timeStr += `.${ms}`; return timeStr;
            },
            escapeHtml(unsafe) { 
                if (typeof unsafe !== 'string') return String(unsafe);
                return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            }
        },

        async init() {
            this.fsApiSupported = 'showOpenFilePicker' in window && 'FileSystemFileHandle' in window;
            if (this.fsApiSupported) {
                console.log("File System Access API is supported.");
                try {
                    await this.initDB();
                } catch (error) {
                    console.error("Failed to initialize IndexedDB for handles:", error);
                    this.showToast("Could not init DB for file handles. File persistence may not work.", "error", 7000);
                    this.fsApiSupported = false; // Disable FS API features if DB fails
                }
            } else {
                console.warn("File System Access API not supported. Falling back to standard file inputs.");
            }
            
            this.cacheDomElements();
            this.setupDynamicFileInputs();
            this.loadData();
            this.registerEventListeners();
            this.adjustHeaderSpacers(); 
            window.addEventListener('resize', () => this.adjustHeaderSpacers());
            this.navigateTo('screen-projects');
            console.log("LogReel App Initialized");
            if (!this.fsApiSupported && !('showOpenFilePicker' in window && 'FileSystemFileHandle' in window)) { // Only show this if FS API truly not supported by browser
                 this.showToast("File System API not supported by this browser. Files will need re-selection each session.", "warning", 7000);
            } else if (!this.fsApiSupported && ('showOpenFilePicker' in window && 'FileSystemFileHandle' in window)) {
                // This means API is available but DB init failed, already shown by the red toast.
                // Optionally add a more specific message if needed, but the red one is key.
            }
        },

        async initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
                request.onerror = (event) => {
                    console.error("IndexedDB error event:", event);
                    console.error("IndexedDB request.error:", request.error); 
                    console.error("IndexedDB event.target.error:", event.target.error); 
                    reject(request.error || event.target.error || new Error("Unknown IndexedDB Error"));
                };
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log("IndexedDB initialized successfully.");
                    resolve(this.db);
                };
                request.onupgradeneeded = (event) => {
                    console.log("IndexedDB onupgradeneeded event:", event);
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(this.STORE_HANDLES)) {
                        db.createObjectStore(this.STORE_HANDLES, { keyPath: 'id' });
                        console.log("File handles object store created.");
                    }
                };
                request.onblocked = (event) => {
                    console.warn("IndexedDB open request blocked:", event);
                    this.showToast("Database access is blocked. Please close other LogReel tabs/windows and refresh.", "warning", 10000);
                    reject(new Error("IndexedDB open request blocked."));
                };
            });
        },

        async saveFileHandle(videoId, fileHandle) {
            if (!this.db || !this.fsApiSupported) return Promise.resolve(); // Changed to return resolved promise
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction([this.STORE_HANDLES], 'readwrite');
                    const store = transaction.objectStore(this.STORE_HANDLES);
                    const request = store.put({ id: videoId, handle: fileHandle });
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error("Error saving file handle:", event.target.error);
                        this.showToast("Failed to save file reference.", "error");
                        reject(event.target.error);
                    };
                } catch (e) {
                    console.error("Error creating IndexedDB transaction for saving handle:", e);
                    this.showToast("Database error while saving file reference.", "error");
                    reject(e);
                }
            });
        },

        async getFileHandle(videoId) {
            if (!this.db || !this.fsApiSupported) return Promise.resolve(null); // Changed to return resolved promise
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction([this.STORE_HANDLES], 'readonly');
                    const store = transaction.objectStore(this.STORE_HANDLES);
                    const request = store.get(videoId);
                    request.onsuccess = (event) => {
                        resolve(event.target.result ? event.target.result.handle : null);
                    };
                    request.onerror = (event) => {
                        console.error("Error getting file handle:", event.target.error);
                        // Don't show toast here, as it might be called frequently. Let caller handle.
                        reject(event.target.error);
                    };
                } catch (e) {
                     console.error("Error creating IndexedDB transaction for getting handle:", e);
                     this.showToast("Database error while retrieving file reference.", "error");
                     reject(e);
                }
            });
        },

        async deleteFileHandle(videoId) {
            if (!this.db || !this.fsApiSupported) return Promise.resolve(); // Changed to return resolved promise
            return new Promise((resolve, reject) => {
                try {
                    const transaction = this.db.transaction([this.STORE_HANDLES], 'readwrite');
                    const store = transaction.objectStore(this.STORE_HANDLES);
                    const request = store.delete(videoId);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error("Error deleting file handle:", event.target.error);
                        this.showToast("Failed to delete file reference from DB.", "error");
                        reject(event.target.error);
                    };
                } catch (e) {
                    console.error("Error creating IndexedDB transaction for deleting handle:", e);
                    this.showToast("Database error while deleting file reference.", "error");
                    reject(e);
                }
            });
        },
        
        setupDynamicFileInputs() {
            const addVideosContainer = document.getElementById('add-videos-action-container');
            addVideosContainer.innerHTML = ''; // Clear previous
            if (this.fsApiSupported) {
                const button = document.createElement('button');
                button.id = 'btn-add-videos-fs';
                button.className = 'button button-primary';
                button.innerHTML = `<span class="button-icon">&#43;</span> Add Videos`;
                button.addEventListener('click', () => this.handleAddVideosFS());
                addVideosContainer.appendChild(button);
            } else {
                const label = document.createElement('label');
                label.className = 'button button-primary file-input-label';
                label.innerHTML = `<span class="button-icon">&#43;</span> Add Videos
                                   <input type="file" id="add-videos-input-fallback" multiple accept="video/*" class="sr-only">`;
                addVideosContainer.appendChild(label);
                this.dom.addVideosInput = document.getElementById('add-videos-input-fallback');
                if(this.dom.addVideosInput) this.dom.addVideosInput.addEventListener('change', (e) => this.handleAddVideosFallback(e.target.files));
            }

            const loggingInputContainer = document.getElementById('video-file-input-logging-container');
            loggingInputContainer.innerHTML = ''; // Clear previous
            const loggingLabel = document.createElement('label');
            loggingLabel.className = 'button button-primary file-input-label mt-1';
            loggingLabel.innerHTML = `Select Video File
                                   <input type="file" id="video-file-input-logging-fallback" accept="video/*" class="sr-only">`;
            loggingInputContainer.appendChild(loggingLabel);
            this.dom.videoFileInputLogging = document.getElementById('video-file-input-logging-fallback');
            if(this.dom.videoFileInputLogging) this.dom.videoFileInputLogging.addEventListener('change', (e) => this.handleVideoFileSelectionForLogging(e.target.files[0]));
        },

        adjustHeaderSpacers() {
            const adjustSpacer = (buttonId, spacerId) => {
                const button = document.getElementById(buttonId);
                const spacer = document.getElementById(spacerId);
                if (button && spacer) {
                    requestAnimationFrame(() => { // Ensure layout is complete
                        const buttonIsVisible = button.offsetParent !== null;
                        if (buttonIsVisible && button.offsetWidth > 0) {
                            spacer.style.width = `${button.offsetWidth}px`;
                        } else {
                            // If button not visible, spacer might not need specific width or uses default
                        }
                    });
                }
            };
            adjustSpacer('btn-back-to-projects', 'project-videos-header-spacer');
            adjustSpacer('btn-back-to-project-videos', 'video-logging-header-spacer');
        },

        cacheDomElements() {
            this.dom.screens = {
                'projects': document.getElementById('screen-projects'),
                'project-videos': document.getElementById('screen-project-videos'),
                'video-logging': document.getElementById('screen-video-logging'),
            };
            this.dom.modals = {
                newProject: document.getElementById('modal-new-project'),
                confirmAction: document.getElementById('modal-confirm-action'),
            };
            this.dom.toastContainer = document.getElementById('toast-container');
            // Screen 1
            this.dom.projectsList = document.getElementById('projects-list');
            this.dom.btnNewProject = document.getElementById('btn-new-project');
            this.dom.importProjectsInput = document.getElementById('import-projects-input');
            
            // Screen 2
            this.dom.btnBackToProjects = document.getElementById('btn-back-to-projects');
            this.dom.projectNameHeader = document.getElementById('project-name-header');
            this.dom.btnExportProject = document.getElementById('btn-export-project');
            this.dom.projectVideosSearch = document.getElementById('project-videos-search');
            this.dom.projectVideosContainer = document.getElementById('project-videos-container');

            // Screen 3
            this.dom.btnBackToProjectVideos = document.getElementById('btn-back-to-project-videos');
            this.dom.videoFilenameHeader = document.getElementById('video-filename-header');
            this.data.videoElement = document.getElementById('video-player');
            this.dom.videoPlayerContainer = document.getElementById('video-player-container'); 
            this.dom.videoFilePrompt = document.getElementById('video-file-prompt');
            this.dom.videoFilePromptMessage = document.getElementById('video-file-prompt-message');
            this.data.timelineContainer = document.getElementById('timeline-container');
            this.data.timelineProgress = document.getElementById('timeline-progress');
            this.data.playPauseBtn = document.getElementById('play-pause-btn');
            this.data.timecodeDisplay = document.getElementById('timecode-display');
            this.data.speedSelect = document.getElementById('speed-select');
            this.data.markInBtn = document.getElementById('mark-in-btn');
            this.data.markOutBtn = document.getElementById('mark-out-btn');
            this.dom.logNotes = document.getElementById('log-notes');
            this.dom.logRatingContainer = document.getElementById('log-rating');
            this.dom.logKeywords = document.getElementById('log-keywords');
            this.dom.saveLogBtn = document.getElementById('save-log-btn');
            this.dom.editingLogIdInput = document.getElementById('editing-log-id');
            this.dom.savedLogsList = document.getElementById('saved-logs-list');
            this.dom.thumbnailCanvas = document.getElementById('thumbnail-canvas');

            // Modals
            this.dom.newProjectNameInput = document.getElementById('new-project-name');
            this.dom.btnCreateProjectConfirm = document.getElementById('btn-create-project-confirm');
            this.dom.confirmActionMessage = document.getElementById('confirm-action-message');
            this.dom.btnConfirmActionCancel = document.getElementById('btn-confirm-action-cancel');
            this.dom.btnConfirmActionConfirm = document.getElementById('btn-confirm-action-confirm');
        },

        navigateTo(screenId, params = {}) {
            const targetScreenKey = screenId.replace('screen-', '');
            Object.values(this.dom.screens).forEach(screen => screen.classList.remove('active'));
            if (this.dom.screens[targetScreenKey]) {
                this.dom.screens[targetScreenKey].classList.add('active');
            } else {
                console.error(`Screen key "${targetScreenKey}" not found. Defaulting to projects.`);
                this.dom.screens['projects'].classList.add('active'); 
                screenId = 'screen-projects';
            }
            this.currentScreen = screenId; window.scrollTo(0, 0);

            if (this.data.activeInlinePlayer.playerElement && this.data.activeInlinePlayer.videoId && screenId !== 'screen-project-videos') {
                this.data.activeInlinePlayer.playerElement.pause();
                const oldPlayerArea = document.getElementById(`inline-player-area-${this.data.activeInlinePlayer.videoId}`);
                if (oldPlayerArea) oldPlayerArea.classList.remove('active');
                // Consider clearing activeInlinePlayer state more fully
                // this.data.activeInlinePlayer = { videoId: null, playerElement: null, promptElement: null, fileInputElement: null, pendingLogIdToPlay: null };
            }
            
            this.adjustHeaderSpacers(); // Call after screen is active for correct measurements

            switch (screenId) {
                case 'screen-projects': this.renderProjectsScreen(); break;
                case 'screen-project-videos':
                    this.data.currentProjectId = params.projectId || this.data.currentProjectId || (this.data.projects[0]?.id);
                    if (!this.data.currentProjectId && this.data.projects.length > 0) {
                        this.data.currentProjectId = this.data.projects[0].id; // Default to first project if none specified
                    }
                    if (!this.data.currentProjectId) { this.navigateTo('screen-projects'); return; }
                    this.renderProjectVideosScreen();
                    break;
                case 'screen-video-logging':
                    if (params.projectId) this.data.currentProjectId = params.projectId;
                    if (params.videoId) this.data.currentVideoId = params.videoId;
                    if (!this.data.currentProjectId || !this.data.currentVideoId) {
                        const targetProj = this.data.currentProjectId || this.data.projects[0]?.id;
                        if(targetProj) this.navigateTo('screen-project-videos', { projectId: targetProj });
                        else this.navigateTo('screen-projects');
                        return;
                    }
                    this.renderVideoLoggingScreen(); 
                    if(params.logIdToEdit) this.editLogEntry(params.logIdToEdit, true);
                    break;
            }
        },

        loadData() { 
            const storedData = localStorage.getItem('logReelData');
            if (storedData) {
                try {
                    const parsedData = JSON.parse(storedData);
                    if (Array.isArray(parsedData)) {
                        this.data.projects = parsedData.map(project => {
                            // Ensure project structure and defaults
                            const p = {
                                id: project.id || this.utils.generateId(),
                                name: project.name || "Untitled Project",
                                videos: [],
                                createdAt: project.createdAt || new Date().toISOString()
                            };
                            if (Array.isArray(project.videos)) {
                                p.videos = project.videos.map(video => {
                                    const v = {
                                        id: video.id || this.utils.generateId(),
                                        filename: video.filename || "unknown.mp4",
                                        logs: [],
                                        createdAt: video.createdAt || new Date().toISOString(),
                                        isImportant: typeof video.isImportant === 'boolean' ? video.isImportant : false
                                    };
                                    if (Array.isArray(video.logs)) {
                                        v.logs = video.logs.map(log => ({
                                            id: log.id || this.utils.generateId(),
                                            markIn: typeof log.markIn === 'number' ? log.markIn : 0,
                                            markOut: typeof log.markOut === 'number' ? log.markOut : 0,
                                            notes: log.notes || "",
                                            rating: typeof log.rating === 'number' ? log.rating : 0,
                                            keywords: Array.isArray(log.keywords) ? log.keywords : [],
                                            thumbnail: log.thumbnail || null,
                                            createdAt: log.createdAt || new Date().toISOString(),
                                            updatedAt: log.updatedAt // May be undefined
                                        }));
                                    }
                                    return v;
                                });
                            }
                            return p;
                        });
                    } else {
                        this.data.projects = [];
                         console.warn("Stored data is not an array, initializing empty projects list.");
                    }
                } catch (e) {
                    console.error("Error parsing data from localStorage:", e);
                    this.showToast("Error loading data. Storage might be corrupted.", "error");
                    this.data.projects = [];
                }
            } else {
                this.data.projects = [];
            }
        },
        saveData() { 
            try {
                localStorage.setItem('logReelData', JSON.stringify(this.data.projects));
            } catch (e) {
                console.error("Error saving data to localStorage:", e);
                this.showToast("Could not save data. Storage might be full or disabled.", "error");
            }
        },
        getProjectById(projectId) { 
            return this.data.projects.find(p => p.id === projectId);
        },
        getVideoById(projectId, videoId) { 
            const project = this.getProjectById(projectId);
            return project?.videos.find(v => v.id === videoId);
        },
        getLogById(projectId, videoId, logId) { 
            const video = this.getVideoById(projectId, videoId);
            return video?.logs?.find(l => l.id === logId);
        },

        registerEventListeners() {
            this.dom.btnNewProject.addEventListener('click', () => this.showNewProjectModal());
            this.dom.importProjectsInput.addEventListener('change', (e) => this.importProjects(e));
            this.dom.btnBackToProjects.addEventListener('click', () => this.navigateTo('screen-projects'));
            this.dom.btnExportProject.addEventListener('click', () => this.exportCurrentProject());
            this.dom.projectVideosSearch.addEventListener('input', (e) => this.renderProjectVideosScreen(e.target.value.trim()));
            this.dom.btnBackToProjectVideos.addEventListener('click', () => this.navigateTo('screen-project-videos', { projectId: this.data.currentProjectId }));
            
            this.data.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
            this.data.videoElement.addEventListener('play', () => { if(this.data.playPauseBtn) {this.data.playPauseBtn.innerHTML = '<span class="button-icon">&#10074;&#10074;</span>Pause'; this.data.playPauseBtn.setAttribute('aria-label', 'Pause video');}});
            this.data.videoElement.addEventListener('pause', () => { if(this.data.playPauseBtn) {this.data.playPauseBtn.innerHTML = '<span class="button-icon">&#9658;</span>Play'; this.data.playPauseBtn.setAttribute('aria-label', 'Play video');}});
            this.data.videoElement.addEventListener('loadedmetadata', () => this.updateVideoTimes());
            this.data.videoElement.addEventListener('timeupdate', () => this.updateVideoTimes());
            this.data.videoElement.addEventListener('durationchange', () => this.updateVideoTimes());
            this.data.videoElement.addEventListener('error', (e) => {
                console.error("Video Player Error (Screen 3):", e, this.data.videoElement.error);
                const videoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
                const errorMsg = this.data.videoElement.error ? ` (Code: ${this.data.videoElement.error.code}, Message: ${this.data.videoElement.error.message})` : '';
                this.showToast(`Error playing ${videoData ? this.utils.escapeHtml(videoData.filename) : 'video'}${errorMsg}. File might be corrupted, unsupported, or network issue.`, 'error', 7000);
                if (videoData) this.promptForVideoFile(videoData.filename, this.dom.videoFilePrompt, this.dom.videoFilePromptMessage, this.dom.videoFileInputLogging, this.data.videoElement);
            });
            this.data.timelineContainer.addEventListener('click', (e) => this.seekVideo(e));
            this.data.speedSelect.addEventListener('change', (e) => { if(this.data.videoElement) this.data.videoElement.playbackRate = parseFloat(e.target.value); });
            this.data.markInBtn.addEventListener('click', () => this.setMarkIn());
            this.data.markOutBtn.addEventListener('click', () => this.setMarkOut());
            this.dom.logRatingContainer.addEventListener('click', (e) => this.handleStarRating(e));
            this.dom.saveLogBtn.addEventListener('click', () => this.saveLogEntry());
            
            document.querySelectorAll('.close-button').forEach(btn => {
                btn.addEventListener('click', () => this.hideModal(btn.dataset.modalId));
            });
            this.dom.btnCreateProjectConfirm.addEventListener('click', () => this.createNewProject());
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const activeModal = document.querySelector('.modal[style*="display: flex"]'); // Changed selector
                    if (activeModal) this.hideModal(activeModal.id);
                }
            });

            this.dom.projectVideosContainer.addEventListener('click', (e) => {
                const targetButton = e.target.closest('button'); if (!targetButton) return;
                const videoEntryCard = targetButton.closest('article.video-entry-card'); if (!videoEntryCard) return; 
                const videoId = videoEntryCard.dataset.videoId;

                if (targetButton.classList.contains('btn-log-full-video')) {
                    this.navigateTo('screen-video-logging', { projectId: this.data.currentProjectId, videoId: videoId });
                } else if (targetButton.classList.contains('btn-delete-this-video')) {
                    this.confirmDeleteVideo(videoId);
                } else if (targetButton.classList.contains('btn-toggle-important')) {
                    this.toggleVideoImportance(videoId);
                } else if (targetButton.classList.contains('btn-play-this-clip-inline')) {
                    const logId = targetButton.dataset.logId;
                    this.playClipInline(videoId, logId);
                } else if (targetButton.classList.contains('btn-edit-this-clip')) {
                    const logId = targetButton.dataset.logId;
                    this.navigateTo('screen-video-logging', { projectId: this.data.currentProjectId, videoId: videoId, logIdToEdit: logId });
                } else if (targetButton.classList.contains('btn-delete-this-log-item')) {
                     const logId = targetButton.dataset.logId;
                     this.confirmDeleteLogItemFromScreen2(videoId, logId);
                }
            });
            this.dom.projectVideosContainer.addEventListener('change', (e) => {
                if (e.target.classList.contains('inline-clip-file-input-fallback')) {
                    const videoEntryCard = e.target.closest('article.video-entry-card');
                    if (!videoEntryCard) return;
                    const videoId = videoEntryCard.dataset.videoId;
                    this.handleInlinePlayerFileSelection(e.target.files[0], videoId);
                }
            });
        },
        
        renderProjectsScreen() { 
            this.dom.projectsList.innerHTML = '';
            if (this.data.projects.length === 0) {
                this.dom.projectsList.innerHTML = '<div class="empty-state"><p>No projects yet.</p><p>Create one or import existing projects to get started!</p></div>';
                return;
            }
            const fragment = document.createDocumentFragment();
            this.data.projects.forEach(project => {
                const card = document.createElement('article'); 
                card.className = 'card project-card';
                card.innerHTML = `
                    <div class="card-title">${this.utils.escapeHtml(project.name)}</div>
                    <div class="card-meta">Contains ${project.videos ? project.videos.length : 0} video(s)</div>
                    <div class="card-actions">
                        <button class="button button-primary btn-open-project" data-project-id="${project.id}">Open Project</button>
                        <button class="button button-subtle btn-delete-project" data-project-id="${project.id}">Delete</button>
                    </div>
                `;
                fragment.appendChild(card);
            });
            this.dom.projectsList.appendChild(fragment);

            this.dom.projectsList.querySelectorAll('.btn-open-project').forEach(btn => {
                btn.addEventListener('click', (e) => this.navigateTo('screen-project-videos', { projectId: e.currentTarget.dataset.projectId }));
            });
            this.dom.projectsList.querySelectorAll('.btn-delete-project').forEach(btn => {
                btn.addEventListener('click', (e) => this.confirmDeleteProject(e.currentTarget.dataset.projectId));
            });
        },
        showNewProjectModal() { 
            this.dom.newProjectNameInput.value = '';
            this.showModal('modal-new-project');
            this.dom.newProjectNameInput.focus();
        },
        createNewProject() { 
            const name = this.dom.newProjectNameInput.value.trim();
            if (!name) { this.showToast('Project name cannot be empty.', 'warning'); return; }
            const newProject = { id: this.utils.generateId(), name: name, videos: [], createdAt: new Date().toISOString() };
            this.data.projects.unshift(newProject); // Add to beginning for most recent first
            this.saveData(); this.renderProjectsScreen(); this.hideModal('modal-new-project');
            this.showToast(`Project "${this.utils.escapeHtml(name)}" created.`, 'success');
        },
        confirmDeleteProject(projectId) { 
            const project = this.getProjectById(projectId);
            if (!project) return;
            const message = `Are you sure you want to delete the project "<strong>${this.utils.escapeHtml(project.name)}</strong>"? <br>This action cannot be undone. All associated video data and logs will be lost.`;
            this.showConfirmationModal(message, () => this.deleteProject(projectId), null, "Delete Project", "button-danger");
        },
        async deleteProject(projectId){ 
            const project = this.getProjectById(projectId);
            if(project?.videos && this.fsApiSupported){
                for(const video of project.videos){
                    try { await this.deleteFileHandle(video.id); } catch(e) { console.warn("Could not delete a file handle during project deletion:", e); }
                }
            }
            this.data.projects = this.data.projects.filter(p => p.id !== projectId);
            if (this.data.currentProjectId === projectId) { this.data.currentProjectId = null; this.data.currentVideoId = null; }
            this.saveData(); this.renderProjectsScreen();
            if(project) this.showToast(`Project "${this.utils.escapeHtml(project.name)}" deleted.`, 'success');
        },
        async importProjects(event) { 
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (Array.isArray(importedData) && importedData.every(p => p.id && p.name && Array.isArray(p.videos))) {
                        // Perform data validation/sanitization similar to loadData if desired
                        importedData.forEach(p => {
                            p.videos.forEach(v => {
                                if(typeof v.isImportant === 'undefined') v.isImportant = false;
                            });
                        });
                        this.showConfirmationModal(
                            "Importing will replace <strong>all current projects and their data</strong>. This action cannot be undone. <br><br><strong>Note:</strong> Video file links will be lost; you'll need to re-link videos after import.",
                            async () => { 
                                if (this.fsApiSupported && this.db) {
                                    try {
                                        const transaction = this.db.transaction([this.STORE_HANDLES], 'readwrite');
                                        const store = transaction.objectStore(this.STORE_HANDLES);
                                        await new Promise((res, rej) => {
                                            const req = store.clear();
                                            req.onsuccess = res;
                                            req.onerror = rej;
                                        });
                                        this.showToast("Cleared existing file references.", "info");
                                    } catch (dbError) {
                                        console.error("Error clearing file handles from DB during import:", dbError);
                                        this.showToast("Could not clear old file references from DB.", "warning");
                                    }
                                }
                                this.data.projects = importedData; 
                                this.saveData(); this.renderProjectsScreen(); 
                                this.showToast('Projects imported successfully! Please re-link video files as needed.', 'success', 6000);
                            },
                            null, "Import & Replace", "button-primary"
                        );
                    } else { this.showToast('Invalid project file format.', 'error'); }
                } catch (error) { this.showToast('Error reading or parsing project file.', 'error'); console.error("Import error:", error); }
            };
            reader.onerror = (err) => { // Added FileReader error handling
                this.showToast('Error reading the project file.', 'error');
                console.error("FileReader error:", err);
            };
            reader.readAsText(file); 
            event.target.value = null; // Clear input to allow re-selection of same file
        },
        exportCurrentProject() { 
            const project = this.getProjectById(this.data.currentProjectId);
            if (!project) { this.showToast("No project selected or found to export.", "warning"); return; }
            
            const projectToExport = JSON.parse(JSON.stringify(project)); 
            // Sanitize further if needed, e.g., remove temporary states not meant for export
            projectToExport.videos.forEach(video => { delete video.fileURL; /* example */ }); 

            const dataStr = JSON.stringify([projectToExport], null, 2); 
            const dataBlob = new Blob([dataStr], {type: "application/json;charset=utf-8"});
            const exportFileDefaultName = `${project.name.replace(/[^\w\s]/gi, '').replace(/\s+/g, '_') || 'LogReel_Project'}_export.json`;
            
            const linkElement = document.createElement('a');
            linkElement.href = URL.createObjectURL(dataBlob);
            linkElement.download = exportFileDefaultName;
            document.body.appendChild(linkElement); // Required for Firefox
            linkElement.click(); 
            document.body.removeChild(linkElement);
            URL.revokeObjectURL(linkElement.href); // Clean up blob URL
            this.showToast(`Project "${this.utils.escapeHtml(project.name)}" export started.`, 'success');
        },

        renderProjectVideosScreen(searchTerm = '') { 
            const project = this.getProjectById(this.data.currentProjectId);
            if (!project) {
                this.navigateTo('screen-projects'); return;
            }
            this.dom.projectNameHeader.textContent = this.utils.escapeHtml(project.name);
            this.dom.projectVideosContainer.innerHTML = '';

            let videosToDisplay = project.videos || [];
            let foundItems = false;
            const fragment = document.createDocumentFragment();
            const lowerSearchTerm = searchTerm.toLowerCase();

            videosToDisplay.sort((a,b) => (a.createdAt || 0) > (b.createdAt || 0) ? 1 : -1) // Example: sort by creation date
            .forEach((video, index) => {
                let videoMatchesSearch = false;
                let clipsToDisplay = video.logs || [];

                if (searchTerm) {
                    if (video.filename.toLowerCase().includes(lowerSearchTerm)) {
                        videoMatchesSearch = true;
                    }
                    clipsToDisplay = clipsToDisplay.filter(log =>
                        log.notes.toLowerCase().includes(lowerSearchTerm) ||
                        (log.keywords && log.keywords.some(k => k.toLowerCase().includes(lowerSearchTerm)))
                    );
                    if (!videoMatchesSearch && clipsToDisplay.length === 0) {
                        return; 
                    }
                }
                foundItems = true;

                const videoCard = document.createElement('article'); 
                videoCard.className = 'video-entry-card';
                videoCard.dataset.videoId = video.id;

                let clipsHtml = '';
                if (clipsToDisplay.length > 0) {
                    clipsToDisplay.sort((a,b) => a.markIn - b.markIn).forEach(log => {
                        const ratingStars = Array(5).fill(0).map((_, i) => `<span class="star ${i < log.rating ? 'selected' : ''}" style="font-size:0.8em; color: ${i < log.rating ? 'var(--warning-color)' : 'var(--border-color)'};">&#9733;</span>`).join('');
                        clipsHtml += `
                            <div class="clip-item-card">
                                <img src="${log.thumbnail || 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='}" alt="Clip thumbnail" class="clip-item-thumbnail">
                                <div class="clip-item-info">
                                    <p class="notes" title="${this.utils.escapeHtml(log.notes)}">${this.utils.escapeHtml(log.notes)}</p>
                                    <p class="time">Time: ${this.utils.formatTime(log.markIn)} - ${this.utils.formatTime(log.markOut)}</p>
                                    <p class="rating">Rating: ${ratingStars}</p>
                                    ${log.keywords && log.keywords.length > 0 ? `<p class="keywords">Keywords: ${this.utils.escapeHtml(log.keywords.join(', '))}</p>` : ''}
                                </div>
                                <div class="clip-item-actions">
                                    <button class="button button-primary button-small btn-play-this-clip-inline" data-log-id="${log.id}" aria-label="Play clip: ${this.utils.escapeHtml(log.notes.substring(0,30))}"><span class="button-icon">&#9658;</span>Play</button>
                                    <button class="button button-subtle button-small btn-edit-this-clip" data-log-id="${log.id}" aria-label="Edit clip: ${this.utils.escapeHtml(log.notes.substring(0,30))}">Edit</button>
                                    <button class="button button-subtle button-small btn-delete-this-log-item" data-log-id="${log.id}" aria-label="Delete clip: ${this.utils.escapeHtml(log.notes.substring(0,30))}">Del</button>
                                </div>
                            </div>
                        `;
                    });
                } else if (searchTerm && videoMatchesSearch) { 
                    clipsHtml = '<p style="padding: 10px 0; text-align:center; color: var(--text-color-light); font-size:0.9em;">No logged clips match search for this video.</p>';
                } else if (!searchTerm) {
                     clipsHtml = '<p style="padding: 10px 0; text-align:center; color: var(--text-color-light); font-size:0.9em;">No clips logged for this video yet.</p>';
                }
                
                const fallbackInlineInputId = `inline-clip-file-input-fallback-${video.id}`;
                const fallbackInlineInputHTML = this.fsApiSupported ? '' : `
                    <label class="button button-primary button-small file-input-label mt-1">
                        Select Video File
                        <input type="file" class="inline-clip-file-input-fallback sr-only" id="${fallbackInlineInputId}" data-video-id-target="${video.id}" accept="video/*">
                    </label>`;

                videoCard.innerHTML = `
                    <div class="video-entry-header">
                        <span class="video-entry-title" title="${this.utils.escapeHtml(video.filename)}">
                           <span class="video-card-number">${index + 1}. </span>${this.utils.escapeHtml(video.filename)}
                        </span>
                        <div class="video-entry-actions">
                             <button class="button button-subtle btn-toggle-important ${video.isImportant ? 'is-important' : ''}" title="${video.isImportant ? 'Unmark as important' : 'Mark as important'}" aria-pressed="${video.isImportant}">
                                <span class="button-icon button-icon-only">${video.isImportant ? '&#9733;' : '&#9734;'}</span>
                            </button>
                            <button class="button button-secondary button-small btn-log-full-video" aria-label="Log full video: ${this.utils.escapeHtml(video.filename)}">Log Video</button>
                            <button class="button button-subtle button-small btn-delete-this-video" aria-label="Delete video: ${this.utils.escapeHtml(video.filename)}">Delete</button>
                        </div>
                    </div>
                    <div class="inline-clip-player-area" id="inline-player-area-${video.id}">
                        <video class="inline-clip-player" id="inline-player-${video.id}" playsinline controls width="100%"></video>
                        <div class="inline-clip-player-prompt hidden" id="inline-player-prompt-${video.id}">
                            <p id="inline-player-prompt-msg-${video.id}">Select video file to play clip.</p>
                            ${fallbackInlineInputHTML}
                        </div>
                    </div>
                    <div class="video-clips-list-container">
                        ${clipsToDisplay.length > 0 || (searchTerm && videoMatchesSearch) ? `<h4>Logged Clips (${clipsToDisplay.length})</h4>` : ''}
                        ${clipsHtml}
                    </div>
                `;
                fragment.appendChild(videoCard);
            });
            this.dom.projectVideosContainer.appendChild(fragment);
            
            if (!foundItems && searchTerm) {
                 this.dom.projectVideosContainer.innerHTML = `<div class="empty-state"><p>No videos or clips found matching "<strong>${this.utils.escapeHtml(searchTerm)}</strong>".</p></div>`;
            } else if (!foundItems && !searchTerm && videosToDisplay.length === 0) { // This handles case after all videos deleted
                 this.dom.projectVideosContainer.innerHTML = '<div class="empty-state"><p>No videos in this project yet.</p><p>Click "Add Videos" to begin.</p></div>';
            }
        },

        async handleAddVideosFS() { 
            if (!this.fsApiSupported) {
                this.showToast("File System API not available for persistent selection.", "warning");
                return;
            }
            const project = this.getProjectById(this.data.currentProjectId);
            if (!project) { this.showToast("No project selected.", "error"); return; }
            if (!project.videos) project.videos = [];

            try {
                const fileHandles = await window.showOpenFilePicker({
                    multiple: true,
                    types: [{ description: 'Video Files', accept: { 'video/*': ['.mp4', '.mov', '.webm', '.mkv', '.avi', '.mpg', '.mpeg', '.wmv', '.flv', '.3gp'] } }]
                });

                let addedCount = 0;
                for (const handle of fileHandles) {
                    if (handle.kind !== 'file') continue;
                    const file = await handle.getFile(); 
                    if (!file.type.startsWith('video/')) {
                         this.showToast(`"${this.utils.escapeHtml(file.name)}" is not a video and was skipped.`, 'warning');
                         continue;
                    }
                    
                    const videoId = this.utils.generateId();
                    await this.saveFileHandle(videoId, handle); // This now returns a promise
                    
                    const newVideo = { 
                        id: videoId, 
                        filename: file.name, 
                        logs: [], 
                        createdAt: new Date().toISOString(),
                        isImportant: false 
                    };
                    project.videos.push(newVideo);
                    addedCount++;
                }

                if (addedCount > 0) {
                    this.saveData(); this.renderProjectVideosScreen(); 
                    this.showToast(`${addedCount} video(s) added with persistent references.`, 'success');
                }
            } catch (err) {
                if (err.name === 'AbortError') {
                    // User cancelled the picker - often no toast needed.
                    console.log("File selection aborted by user.");
                } else {
                    console.error("Error picking files with FS API:", err);
                    this.showToast('Error selecting files. Check console for details.', 'error');
                }
            }
        },
        handleAddVideosFallback(files) { 
            const project = this.getProjectById(this.data.currentProjectId);
            if (!project) { this.showToast("No project selected.", "error"); return; }
            if (!project.videos) project.videos = [];
            let addedCount = 0;
            for (let file of files) {
                if (file.type.startsWith('video/')) {
                    const videoId = this.utils.generateId();
                    
                    // Revoke old object URL for this filename if it exists from a previous non-FS selection
                    if (this.data.videoFileCache[file.name]) {
                        URL.revokeObjectURL(this.data.videoFileCache[file.name]);
                    }
                    const objectURL = URL.createObjectURL(file);
                    this.data.videoFileCache[file.name] = objectURL; 
                    
                    const newVideo = { 
                        id: videoId, 
                        filename: file.name, 
                        logs: [], 
                        createdAt: new Date().toISOString(),
                        isImportant: false 
                    };
                    project.videos.push(newVideo);
                    addedCount++;
                } else { this.showToast(`File "${this.utils.escapeHtml(file.name)}" is not a video and was skipped.`, 'warning'); }
            }
            if(addedCount > 0) {
                this.saveData(); this.renderProjectVideosScreen(); 
                this.showToast(`${addedCount} video(s) added (session only).`, 'success');
            }
            if(this.dom.addVideosInput) this.dom.addVideosInput.value = null; // Clear input
        },
        confirmDeleteVideo(videoId) { 
            const video = this.getVideoById(this.data.currentProjectId, videoId);
            if (!video) return;
            const message = `Are you sure you want to delete the video "<strong>${this.utils.escapeHtml(video.filename)}</strong>" and all its logs? <br>This cannot be undone.`;
            this.showConfirmationModal(message, () => this.deleteVideo(videoId), null, "Delete Video", "button-danger");
        },
        async deleteVideo(videoId) { 
            const project = this.getProjectById(this.data.currentProjectId);
            if (!project || !project.videos) return;
            const videoToDelete = project.videos.find(v => v.id === videoId);
            
            if (videoToDelete && this.data.videoFileCache[videoToDelete.filename]) {
                 URL.revokeObjectURL(this.data.videoFileCache[videoToDelete.filename]); 
                 delete this.data.videoFileCache[videoToDelete.filename];
            }
            if (this.fsApiSupported && videoToDelete) { 
                try { await this.deleteFileHandle(videoId); } catch(e) { console.warn("Could not delete file handle from DB for video:", videoId, e); }
            }

            project.videos = project.videos.filter(v => v.id !== videoId);
            if (this.data.currentVideoId === videoId) { this.data.currentVideoId = null; }
            if (this.data.activeInlinePlayer.videoId === videoId) {
                const oldPlayerArea = document.getElementById(`inline-player-area-${this.data.activeInlinePlayer.videoId}`);
                if (oldPlayerArea) oldPlayerArea.classList.remove('active');
                if (this.data.activeInlinePlayer.playerElement) this.data.activeInlinePlayer.playerElement.src = ''; // Clear src
                this.data.activeInlinePlayer = { videoId: null, playerElement: null, promptElement: null, fileInputElement: null, pendingLogIdToPlay: null };
            }
            this.saveData(); this.renderProjectVideosScreen();
            if (videoToDelete) this.showToast(`Video "${this.utils.escapeHtml(videoToDelete.filename)}" deleted.`, 'success');
        },
        toggleVideoImportance(videoId) { 
            const project = this.getProjectById(this.data.currentProjectId);
            if (!project) return;
            const video = project.videos.find(v => v.id === videoId);
            if (!video) return;

            video.isImportant = !video.isImportant;
            this.saveData();
            this.renderProjectVideosScreen(this.dom.projectVideosSearch.value.trim()); 
            this.showToast(`Video "${this.utils.escapeHtml(video.filename)}" marked as ${video.isImportant ? 'important' : 'not important'}.`, 'info');
        },

        async loadVideoSource(videoData, videoElement, promptContainer, promptMessageElem, fallbackInputElement, isInlinePlayer = false) {
            videoElement.pause();
            videoElement.removeAttribute('src'); // Ensures old source is cleared
            // videoElement.load(); // Generally not needed if src is set directly after
            if(promptContainer) promptContainer.classList.add('hidden');
            videoElement.classList.add('hidden'); 

            const cachedObjectURL = this.data.videoFileCache[videoData.filename];
            if (cachedObjectURL) {
                try {
                    // Test if object URL is still valid by trying to fetch (optional, but good for robustness)
                    // For local blob URLs, this fetch might not be strictly necessary if you trust the cache lifetime
                    // but it's a good check if URLs could come from elsewhere or have very short lives.
                    // For simplicity here, we'll assume if it's in cache, it's usable for the session.
                    // const response = await fetch(cachedObjectURL, {method: 'HEAD'});
                    // if (response.ok) {
                        videoElement.src = cachedObjectURL;
                        videoElement.classList.remove('hidden');
                        if (promptContainer) promptContainer.classList.add('hidden');
                        return true; 
                    // } else {
                    //     URL.revokeObjectURL(cachedObjectURL);
                    //     delete this.data.videoFileCache[videoData.filename];
                    // }
                } catch (e) { 
                    console.warn("Error trying to use cached object URL, revoking:", e);
                    URL.revokeObjectURL(cachedObjectURL);
                    delete this.data.videoFileCache[videoData.filename];
                }
            }
            
            if (this.fsApiSupported) {
                let handle = null;
                try { handle = await this.getFileHandle(videoData.id); } catch (e) { console.error("DB error getting handle:", e); }

                if (handle) {
                    try {
                        let permState = await handle.queryPermission({ mode: 'read' });
                        if (permState === 'prompt') {
                            this.showToast(`Requesting permission for "${this.utils.escapeHtml(videoData.filename)}"`, "info", 4000);
                            permState = await handle.requestPermission({ mode: 'read' });
                        }

                        if (permState === 'granted') {
                            const file = await handle.getFile();
                            // Revoke old object URL if exists for this filename, before creating new one
                            if (this.data.videoFileCache[file.name]) {
                                URL.revokeObjectURL(this.data.videoFileCache[file.name]);
                            }
                            const objectURL = URL.createObjectURL(file);
                            this.data.videoFileCache[file.name] = objectURL; // Cache new URL
                            videoElement.src = objectURL;
                            videoElement.classList.remove('hidden');
                            if (promptContainer) promptContainer.classList.add('hidden');
                            return true; 
                        } else {
                            this.showToast(`Permission denied for "${this.utils.escapeHtml(videoData.filename)}". Please re-select.`, "warning");
                        }
                    } catch (err) {
                        console.error("Error accessing file via handle:", err);
                        this.showToast(`Error accessing saved reference for "${this.utils.escapeHtml(videoData.filename)}". File might have been moved or permissions changed.`, "error", 6000);
                    }
                } else if (this.fsApiSupported) { // Handle existed but could not be retrieved from DB, or DB error
                     // No specific message if getFileHandle itself failed quietly, as it would have logged
                }
            }

            this.promptForVideoFile(videoData.filename, promptContainer, promptMessageElem, fallbackInputElement, videoElement);
            return false; 
        },

        async playClipInline(videoId, logId) {
            const videoData = this.getVideoById(this.data.currentProjectId, videoId);
            const logData = this.getLogById(this.data.currentProjectId, videoId, logId);
            if (!videoData || !logData) { this.showToast("Clip or video data not found.", "error"); return; }

            if (this.data.activeInlinePlayer.playerElement && this.data.activeInlinePlayer.videoId !== videoId) {
                this.data.activeInlinePlayer.playerElement.pause();
                this.data.activeInlinePlayer.playerElement.removeAttribute('src');
                const oldPlayerArea = document.getElementById(`inline-player-area-${this.data.activeInlinePlayer.videoId}`);
                if (oldPlayerArea) oldPlayerArea.classList.remove('active');
                if(this.data.activeInlinePlayer.promptElement) this.data.activeInlinePlayer.promptElement.classList.add('hidden');
            }
            
            const playerArea = document.getElementById(`inline-player-area-${videoId}`);
            const player = document.getElementById(`inline-player-${videoId}`);
            const promptContainer = document.getElementById(`inline-player-prompt-${videoId}`);
            const promptMsgElem = document.getElementById(`inline-player-prompt-msg-${videoId}`);
            const fallbackInput = this.fsApiSupported ? null : document.getElementById(`inline-clip-file-input-fallback-${videoId}`);


            if (!playerArea || !player || !promptContainer) { console.error("Inline player elements not found for videoId:", videoId); return; }
            
            playerArea.classList.add('active'); 
            player.closest('article.video-entry-card').scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            this.data.activeInlinePlayer = { videoId, playerElement: player, promptElement: promptContainer, fileInputElement: fallbackInput, pendingLogIdToPlay: logId };
            
            player.onerror = (e) => { 
                console.error("Inline Player Error:", e, player.error);
                const errorMsg = player.error ? ` (Code: ${player.error.code}, Message: ${player.error.message})` : '';
                this.showToast(`Error playing clip from "${this.utils.escapeHtml(videoData.filename)}"${errorMsg}.`, 'error', 7000);
                this.promptForVideoFile(videoData.filename, promptContainer, promptMsgElem, fallbackInput, player);
                player.onerror = null; 
            };

            const loaded = await this.loadVideoSource(videoData, player, promptContainer, promptMsgElem, fallbackInput, true);
            if (loaded) {
                player.currentTime = logData.markIn; 
                let playAttempted = false;
                const playClip = () => {
                    if (playAttempted) return;
                    playAttempted = true;
                    player.play().then(() => {
                        if (logData.markOut) { 
                            const pauseAtMarkOut = () => {
                                if (player.currentTime >= logData.markOut) {
                                    player.pause();
                                    player.removeEventListener('timeupdate', pauseAtMarkOut);
                                }
                            };
                            player.addEventListener('timeupdate', pauseAtMarkOut);
                        }
                    }).catch(e => {
                        console.error("Inline play() rejected:", e);
                        // This might happen due to autoplay restrictions. User might need to interact.
                        this.showToast("Could not autoplay clip. Browser may require interaction.", "warning");
                    });
                };

                if (player.readyState >= player.HAVE_FUTURE_DATA) { // or HAVE_ENOUGH_DATA
                    playClip();
                } else {
                    player.oncanplay = () => {
                        playClip();
                        player.oncanplay = null; // Clean up
                    };
                }
                this.data.activeInlinePlayer.pendingLogIdToPlay = null; 
            } else {
                 this.data.activeInlinePlayer.pendingLogIdToPlay = logId; 
            }
        },
        
        handleInlinePlayerFileSelection(file, videoId) { 
            const videoData = this.getVideoById(this.data.currentProjectId, videoId);
            if (!file || !videoData ) { this.showToast(`Error: Video data not found for ID ${videoId}.`, "error"); return; }
            if(file.name !== videoData.filename){ this.showToast(`Incorrect file. Expected "${this.utils.escapeHtml(videoData.filename)}", got "${this.utils.escapeHtml(file.name)}".`, "warning", 5000); return; }

            if (this.data.videoFileCache[file.name]) URL.revokeObjectURL(this.data.videoFileCache[file.name]);
            const objectURL = URL.createObjectURL(file);
            this.data.videoFileCache[file.name] = objectURL; 

            if (this.data.activeInlinePlayer.videoId === videoId && this.data.activeInlinePlayer.playerElement) {
                this.data.activeInlinePlayer.promptElement.classList.add('hidden');
                this.data.activeInlinePlayer.playerElement.classList.remove('hidden');
                this.data.activeInlinePlayer.playerElement.src = objectURL; 

                if (this.data.activeInlinePlayer.pendingLogIdToPlay) {
                    const logData = this.getLogById(this.data.currentProjectId, videoId, this.data.activeInlinePlayer.pendingLogIdToPlay);
                    if(logData) {
                        this.data.activeInlinePlayer.playerElement.currentTime = logData.markIn;
                         let playAttempted = false;
                        const playClip = () => {
                            if (playAttempted) return;
                            playAttempted = true;
                            this.data.activeInlinePlayer.playerElement.play().then(() => {
                                if (logData.markOut) {
                                    const pauseAtMarkOut = () => {
                                        if (this.data.activeInlinePlayer.playerElement.currentTime >= logData.markOut) {
                                            this.data.activeInlinePlayer.playerElement.pause();
                                            this.data.activeInlinePlayer.playerElement.removeEventListener('timeupdate', pauseAtMarkOut);
                                        }
                                    };
                                    this.data.activeInlinePlayer.playerElement.addEventListener('timeupdate', pauseAtMarkOut);
                                }
                            }).catch(e => console.error("Error playing pending clip:", e));
                        };
                         if (this.data.activeInlinePlayer.playerElement.readyState >= this.data.activeInlinePlayer.playerElement.HAVE_FUTURE_DATA) {
                            playClip();
                        } else {
                            this.data.activeInlinePlayer.playerElement.oncanplay = () => {
                                playClip();
                                this.data.activeInlinePlayer.playerElement.oncanplay = null;
                            };
                        }
                        this.data.activeInlinePlayer.pendingLogIdToPlay = null;
                    }
                } else {
                    this.showToast(`"${this.utils.escapeHtml(file.name)}" loaded. Click "Play" on a clip.`, 'info');
                }
            }
             if(this.data.activeInlinePlayer.fileInputElement) this.data.activeInlinePlayer.fileInputElement.value = '';
        },
        confirmDeleteLogItemFromScreen2(videoId, logId){ 
            const log = this.getLogById(this.data.currentProjectId, videoId, logId);
            if (!log) return;
            const message = `Are you sure you want to delete this log entry? <br><small style="color:var(--text-color-light);">${this.utils.escapeHtml(log.notes.substring(0,50))}...</small><br>This action cannot be undone.`;
            this.showConfirmationModal(message, () => this.deleteLogItem(videoId, logId), null, "Delete Log", "button-danger");
        },
        deleteLogItem(videoId, logId) { // Used by Screen 2
            const video = this.getVideoById(this.data.currentProjectId, videoId);
            if (!video || !video.logs) return;
            const logToDelete = video.logs.find(l => l.id === logId);
            video.logs = video.logs.filter(l => l.id !== logId);
            this.saveData();
            this.renderProjectVideosScreen(this.dom.projectVideosSearch.value.trim()); 
            if(logToDelete) this.showToast(`Log entry deleted.`, 'success');
        },

        async renderVideoLoggingScreen() { 
            const videoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
            if (!videoData) { 
                this.navigateTo('screen-project-videos', { projectId: this.data.currentProjectId }); 
                this.showToast("Error: Video not found for logging.", "error"); 
                return; 
            }
            this.dom.videoFilenameHeader.textContent = this.utils.escapeHtml(videoData.filename);
            this.resetLogForm(); this.renderSavedLogsList();
            
            this.data.videoElement.pause(); 
            this.data.videoElement.removeAttribute('src'); 
            this.data.playPauseBtn.innerHTML = '<span class="button-icon">&#9658;</span>Play';
            this.data.playPauseBtn.setAttribute('aria-label', 'Play video');
            this.updateVideoTimes(); 
            
            await this.loadVideoSource(
                videoData, 
                this.data.videoElement, 
                this.dom.videoFilePrompt, 
                this.dom.videoFilePromptMessage, 
                this.dom.videoFileInputLogging
            );
        },
        promptForVideoFile(filename, promptContainer, promptMessageElem, fallbackInputElement, videoPlayerElement) { 
            if (videoPlayerElement) videoPlayerElement.classList.add('hidden'); 
            if (promptContainer) promptContainer.classList.remove('hidden'); 
            if (promptMessageElem) {
                 promptMessageElem.innerHTML = `To use "<strong>${this.utils.escapeHtml(filename)}</strong>", please select the file. <br><small>${this.fsApiSupported ? "If permission was granted previously, it might need to be re-confirmed via a browser prompt when loading." : "File access is for the current session only."}</small>`;
            }
            if (fallbackInputElement) { // This is for screen 3's main player fallback
                fallbackInputElement.dataset.expectedFilename = filename; 
                fallbackInputElement.value = ''; // Clear previous selection
            } else if (this.data.activeInlinePlayer.fileInputElement && this.data.activeInlinePlayer.promptElement === promptContainer) { // For inline player fallback
                this.data.activeInlinePlayer.fileInputElement.dataset.expectedFilename = filename;
                this.data.activeInlinePlayer.fileInputElement.value = '';
            }
        },
        handleVideoFileSelectionForLogging(file) { 
            const expectedFilename = this.dom.videoFileInputLogging.dataset.expectedFilename;
            if (file && file.name === expectedFilename) {
                if (this.data.videoFileCache[file.name]) URL.revokeObjectURL(this.data.videoFileCache[file.name]);
                const objectURL = URL.createObjectURL(file); 
                this.data.videoFileCache[file.name] = objectURL; 
                this.data.videoElement.src = objectURL; 
                this.dom.videoFilePrompt.classList.add('hidden'); 
                this.data.videoElement.classList.remove('hidden'); 
            } else if (file) { 
                this.showToast(`Incorrect file. Expected "${this.utils.escapeHtml(expectedFilename)}", got "${this.utils.escapeHtml(file.name)}".`, 'warning', 5000);
            }
            this.dom.videoFileInputLogging.value = ''; 
        },
        updateVideoTimes() { 
            if (!this.data.videoElement || isNaN(this.data.videoElement.duration) || this.data.videoElement.duration === Infinity) {
                this.data.timecodeDisplay.textContent = '00:00 / --:--'; this.data.timelineProgress.style.width = '0%';
                if(this.data.markInBtn) this.data.markInBtn.textContent = `Mark In (--:--.-)`;
                if(this.data.markOutBtn) this.data.markOutBtn.textContent = `Mark Out (--:--.-)`; return;
            }
            const currentTime = this.data.videoElement.currentTime || 0; const duration = this.data.videoElement.duration;
            this.data.timecodeDisplay.textContent = `${this.utils.formatTime(currentTime)} / ${this.utils.formatTime(duration)}`;
            this.data.timelineProgress.style.width = duration > 0 ? `${(currentTime / duration) * 100}%` : '0%';
            if (this.data.markInTime === 0 || this.data.markInBtn.classList.contains('default-mark')) { this.data.markInBtn.textContent = `Mark In (${this.utils.formatTime(currentTime, true)})`; }
            if (this.data.markOutTime === null || this.data.markOutBtn.classList.contains('default-mark')) { this.data.markOutBtn.textContent = `Mark Out (${this.utils.formatTime(currentTime, true)})`; }
        },
        togglePlayPause() { 
            if (!this.data.videoElement.src || this.dom.videoFilePrompt.classList.contains('hidden') === false) { 
                const currentVideoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
                this.showToast("Please select a video file first.", "warning"); 
                if (currentVideoData) this.promptForVideoFile(currentVideoData.filename, this.dom.videoFilePrompt, this.dom.videoFilePromptMessage, this.dom.videoFileInputLogging, this.data.videoElement);
                return; 
            }
            if (this.data.videoElement.paused || this.data.videoElement.ended) { this.data.videoElement.play().catch(e => {
                console.error("Error playing video:", e);
                this.showToast("Could not play video. " + (e.message || ""), "error");
            }); } else { this.data.videoElement.pause(); }
        },
        seekVideo(event) { 
            if (!this.data.videoElement.duration || isNaN(this.data.videoElement.duration) || !this.data.videoElement.src || this.dom.videoFilePrompt.classList.contains('hidden') === false) return;
            const timelineRect = this.data.timelineContainer.getBoundingClientRect();
            const clickX = event.clientX - timelineRect.left;
            const seekRatio = Math.max(0, Math.min(1, clickX / timelineRect.width));
            this.data.videoElement.currentTime = seekRatio * this.data.videoElement.duration;
        },
        setMarkIn() { 
            if (!this.data.videoElement.src || this.dom.videoFilePrompt.classList.contains('hidden') === false) { this.showToast("Load video first.", "warning"); return; }
            this.data.markInTime = this.data.videoElement.currentTime;
            this.data.markInBtn.textContent = `Mark In (${this.utils.formatTime(this.data.markInTime, true)})`;
            this.data.markInBtn.classList.remove('default-mark', 'button-secondary'); this.data.markInBtn.classList.add('button-primary'); 
            setTimeout(() => { this.data.markInBtn.classList.remove('button-primary'); this.data.markInBtn.classList.add('button-secondary');}, 1000);
            if (this.data.markOutTime !== null && this.data.markOutTime < this.data.markInTime) {
                this.data.markOutTime = null; this.data.markOutBtn.textContent = `Mark Out (${this.utils.formatTime(this.data.videoElement.currentTime, true)})`;
                this.data.markOutBtn.classList.add('default-mark');
            }
        },
        setMarkOut() { 
            if (!this.data.videoElement.src || this.dom.videoFilePrompt.classList.contains('hidden') === false) { this.showToast("Load video first.", "warning"); return; }
            const currentTime = this.data.videoElement.currentTime;
            if (currentTime <= this.data.markInTime) { this.showToast("Mark Out time must be after Mark In time.", "warning"); return; }
            this.data.markOutTime = currentTime;
            this.data.markOutBtn.textContent = `Mark Out (${this.utils.formatTime(this.data.markOutTime, true)})`;
            this.data.markOutBtn.classList.remove('default-mark', 'button-secondary'); this.data.markOutBtn.classList.add('button-primary');
            setTimeout(() => { this.data.markOutBtn.classList.remove('button-primary'); this.data.markOutBtn.classList.add('button-secondary'); }, 1000);
        },
        handleStarRating(event) { 
            const starButton = event.target.closest('button.star');
            if (starButton) { 
                this.data.currentRating = parseInt(starButton.dataset.value); 
                this.updateStarDisplay(); 
            }
        },
        updateStarDisplay() { 
            this.dom.logRatingContainer.querySelectorAll('button.star').forEach(star => {
                const selected = parseInt(star.dataset.value) <= this.data.currentRating;
                star.classList.toggle('selected', selected);
                star.setAttribute('aria-pressed', selected ? 'true' : 'false');
            });
        },
        async saveLogEntry() { 
            const notes = this.dom.logNotes.value.trim();
            const keywordsRaw = this.dom.logKeywords.value.trim();
            const keywords = keywordsRaw ? keywordsRaw.split(',').map(k => k.trim()).filter(k => k) : [];
            if (this.data.markOutTime === null || this.data.markOutTime <= this.data.markInTime) { this.showToast("Please set valid Mark In and Mark Out times.", "warning"); return; }
            if (!notes) { this.showToast("Notes cannot be empty.", "warning"); return; }
            if (this.data.currentRating === 0) { this.showToast("Please provide a rating.", "warning"); return; }
            
            this.dom.saveLogBtn.disabled = true; this.dom.saveLogBtn.textContent = 'Saving...';
            let thumbnail = null;
            try {
                if (this.data.videoElement.src && this.data.videoElement.readyState >= 2 && this.dom.videoFilePrompt.classList.contains('hidden')) { 
                    thumbnail = await this.generateLogThumbnail(this.data.markInTime); 
                } 
                else { console.warn("Video not ready or available for thumbnail generation."); }
            } catch (error) { console.error("Error generating thumbnail:", error); this.showToast("Could not generate thumbnail.", "warning");}
            
            const video = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
            if (!video) { this.showToast("Error: Video not found.", "error"); this.dom.saveLogBtn.disabled = false; this.dom.saveLogBtn.textContent = 'Save Log'; return; }
            if (!video.logs) video.logs = [];

            const editingLogId = this.dom.editingLogIdInput.value;
            const logData = { markIn: this.data.markInTime, markOut: this.data.markOutTime, notes: notes, rating: this.data.currentRating, keywords: keywords, thumbnail: thumbnail };
            
            if (editingLogId) { 
                const logIndex = video.logs.findIndex(l => l.id === editingLogId);
                if (logIndex > -1) { 
                    const originalLog = video.logs[logIndex];
                    video.logs[logIndex] = { ...originalLog, ...logData, updatedAt: new Date().toISOString() };
                    this.showToast("Log entry updated.", "success");
                } else {
                    this.showToast("Error: Log entry to edit not found.", "error");
                    // Fallback to creating new if not found, or handle error differently
                    logData.id = this.utils.generateId();
                    logData.createdAt = new Date().toISOString();
                    video.logs.push(logData);
                    this.showToast("Log entry saved as new.", "info");
                }
            } else { 
                logData.id = this.utils.generateId();
                logData.createdAt = new Date().toISOString();
                video.logs.push(logData); 
                this.showToast("Log entry saved.", "success");
            }
            this.saveData(); this.renderSavedLogsList(); this.resetLogForm();
            this.dom.saveLogBtn.disabled = false; this.dom.saveLogBtn.textContent = 'Save Log';
        },
        generateLogThumbnail(time) { 
            return new Promise((resolve, reject) => {
                if (!this.data.videoElement || !this.data.videoElement.src || this.data.videoElement.readyState < 2 || this.dom.videoFilePrompt.classList.contains('hidden')) { 
                    return reject(new Error("Video not ready or available for thumbnail.")); 
                }
                const video = this.data.videoElement; const canvas = this.dom.thumbnailCanvas; const ctx = canvas.getContext('2d');
                const originalTime = video.currentTime; const originalPaused = video.paused; const originalMuted = video.muted; 
                video.muted = true; // Mute to avoid sound blips during seek
                let seekTimeoutId;

                const cleanup = () => {
                    video.removeEventListener('seeked', onSeeked); 
                    video.removeEventListener('error', onSeekError);
                    clearTimeout(seekTimeoutId);
                    video.currentTime = originalTime; 
                    if (!originalPaused && video.paused) { // Only play if it was playing and is now paused
                         video.play().catch(e=>console.warn("Resume play failed in thumbnail cleanup:",e)); 
                    }
                    video.muted = originalMuted;
                };

                const onSeeked = () => {
                    cleanup();
                    requestAnimationFrame(() => { // Ensure frame is rendered
                        const aspectRatio = video.videoWidth / video.videoHeight; 
                        canvas.width = 160; 
                        canvas.height = canvas.width / aspectRatio; 
                        if (isNaN(canvas.height) || !isFinite(canvas.height) || canvas.height <= 0) {
                            canvas.height = 90; // Fallback height
                        }
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        try { 
                            resolve(canvas.toDataURL('image/jpeg', 0.75)); // Slightly better quality
                        } catch (e) { 
                            console.error("Canvas toDataURL error for thumbnail:", e); 
                            reject(new Error("Error creating thumbnail from canvas.")); 
                        }
                    });
                };
                const onSeekError = (e) => {
                    cleanup();
                    console.error("Error seeking video for thumbnail:", e); 
                    reject(new Error("Error seeking video for thumbnail."));
                };

                video.addEventListener('seeked', onSeeked, { once: true }); 
                video.addEventListener('error', onSeekError, { once: true });
                if (!originalPaused) video.pause(); // Pause if it was playing
                
                // Check if already at the target time to avoid unnecessary seek
                if (Math.abs(video.currentTime - time) < 0.1) { // 100ms tolerance
                    onSeeked(); // Already there, proceed to capture
                } else {
                    video.currentTime = time;
                    seekTimeoutId = setTimeout(() => { 
                        console.warn("Thumbnail generation using timeout fallback for seeked event.");
                        if (video.readyState >= video.HAVE_CURRENT_DATA) {
                            onSeeked(); 
                        } else {
                            console.error("Thumbnail generation failed: Video not ready after seek timeout.");
                            onSeekError(new Error("Seek timeout - video not ready for thumbnail."));
                        }
                    }, 1500); 
                }
            });
        },
        resetLogForm() { 
            this.dom.logNotes.value = ''; this.dom.logKeywords.value = ''; this.data.currentRating = 0; this.updateStarDisplay();
            this.data.markInTime = 0; this.data.markOutTime = null;
            const defaultTime = (this.data.videoElement && this.data.videoElement.src && !this.dom.videoFilePrompt.classList.contains('hidden')) ? (this.data.videoElement.currentTime || 0) : 0;
            this.data.markInBtn.textContent = `Mark In (${this.utils.formatTime(defaultTime, true)})`; this.data.markInBtn.classList.add('default-mark');
            this.data.markOutBtn.textContent = `Mark Out (${this.utils.formatTime(defaultTime, true)})`; this.data.markOutBtn.classList.add('default-mark');
            this.dom.editingLogIdInput.value = ''; this.dom.saveLogBtn.textContent = 'Save Log'; this.dom.saveLogBtn.disabled = false;
        },
        renderSavedLogsList() { 
            const video = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
            this.dom.savedLogsList.innerHTML = '';
            if (!video || !video.logs || video.logs.length === 0) {
                this.dom.savedLogsList.innerHTML = '<div class="empty-state" style="padding:20px; font-size:0.9em;"><p>No logs saved for this video yet.</p></div>';
                return;
            }
            const fragment = document.createDocumentFragment();
            const sortedLogs = [...video.logs].sort((a, b) => a.markIn - b.markIn);
            sortedLogs.forEach(log => {
                const item = document.createElement('article'); 
                item.className = 'log-item'; item.id = `log-item-${log.id}`;
                const ratingStars = Array(5).fill(0).map((_, i) => `<span class="star ${i < log.rating ? 'selected' : ''}" style="font-size:0.8em; color: ${i < log.rating ? 'var(--warning-color)' : 'var(--border-color)'};">&#9733;</span>`).join('');
                item.innerHTML = `
                    <div class="log-item-header">
                        <span class="log-item-time">${this.utils.formatTime(log.markIn)} - ${this.utils.formatTime(log.markOut)}</span>
                        <div class="log-item-rating">${ratingStars}</div>
                    </div>
                    <p class="log-item-notes" title="${this.utils.escapeHtml(log.notes)}">${this.utils.escapeHtml(log.notes)}</p>
                    ${log.keywords && log.keywords.length > 0 ? `<p class="log-item-keywords">Keywords: ${this.utils.escapeHtml(log.keywords.join(', '))}</p>` : ''}
                    ${log.thumbnail ? `<img src="${log.thumbnail}" alt="Log thumbnail">` : ''}
                    <div class="card-actions" style="margin-top:10px;">
                        <button class="button button-subtle button-small btn-go-to-log-time" data-time="${log.markIn}" aria-label="Go to time ${this.utils.formatTime(log.markIn)}">Go to</button>
                        <button class="button button-secondary button-small btn-edit-log" data-log-id="${log.id}" aria-label="Edit log: ${this.utils.escapeHtml(log.notes.substring(0,30))}">Edit</button>
                        <button class="button button-subtle button-small btn-delete-log" data-log-id="${log.id}" aria-label="Delete log: ${this.utils.escapeHtml(log.notes.substring(0,30))}">Delete</button>
                    </div>
                `;
                fragment.appendChild(item);
            });
            this.dom.savedLogsList.appendChild(fragment);

            this.dom.savedLogsList.querySelectorAll('.btn-go-to-log-time').forEach(btn => {
                btn.addEventListener('click', (e) => this.goToLogTime(parseFloat(e.currentTarget.dataset.time)));
            });
            this.dom.savedLogsList.querySelectorAll('.btn-edit-log').forEach(btn => { 
                btn.addEventListener('click', (e) => this.editLogEntry(e.currentTarget.dataset.logId));
            });
            this.dom.savedLogsList.querySelectorAll('.btn-delete-log').forEach(btn => { 
                btn.addEventListener('click', (e) => this.confirmDeleteLogOnScreen3(e.currentTarget.dataset.logId));
            });
        },
        goToLogTime(time) { 
            if(this.data.videoElement && this.data.videoElement.src && !this.dom.videoFilePrompt.classList.contains('hidden')) {
                this.data.videoElement.currentTime = time; 
                this.data.videoElement.play().catch(e => {
                    console.error("Play error on GoToLogTime:", e);
                    // Often due to user not interacting yet.
                });
                this.data.videoElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else { 
                const currentVideoData = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
                this.showToast("Video file not loaded. Please select it first.", "warning"); 
                if(currentVideoData) this.promptForVideoFile(currentVideoData.filename, this.dom.videoFilePrompt, this.dom.videoFilePromptMessage, this.dom.videoFileInputLogging, this.data.videoElement);
            }
        },
        editLogEntry(logId, fromNavigation = false) { 
            const videoIdForLog = this.data.currentVideoId; 
            const log = this.getLogById(this.data.currentProjectId, videoIdForLog, logId);
            if (!log) {
                this.showToast("Log entry not found for editing.", "error");
                return;
            }

            this.dom.logNotes.value = log.notes;
            this.dom.logKeywords.value = log.keywords ? log.keywords.join(', ') : '';
            this.data.currentRating = log.rating; this.updateStarDisplay();
            this.data.markInTime = log.markIn; this.data.markOutTime = log.markOut;
            
            if (this.data.videoElement && this.data.videoElement.src && !this.dom.videoFilePrompt.classList.contains('hidden')) { 
                this.data.videoElement.currentTime = log.markIn; 
            } else if (!fromNavigation) { // If navigating here to edit, video might not be loaded yet
                 this.showToast("Video not loaded. Mark In time set, but player won't seek.", "info");
            }
            this.updateVideoTimes(); // Update buttons with new markIn/Out immediately
            this.data.markInBtn.classList.remove('default-mark'); 
            this.data.markOutBtn.classList.remove('default-mark');
            this.dom.editingLogIdInput.value = log.id; this.dom.saveLogBtn.textContent = 'Update Log';
            
            const logFormCard = this.dom.logNotes.closest('article.card');
            if (logFormCard) {
                logFormCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            this.dom.logNotes.focus();
        },
        confirmDeleteLogOnScreen3(logId) { 
            const log = this.getLogById(this.data.currentProjectId, this.data.currentVideoId, logId);
            if (!log) return;
            const message = `Are you sure you want to delete this log entry? <br><small style="color:var(--text-color-light);">${this.utils.escapeHtml(log.notes.substring(0,50))}...</small><br>This action cannot be undone.`;
            this.showConfirmationModal(message, () => this.deleteLogOnScreen3(logId), null, "Delete Log", "button-danger");
        },
        deleteLogOnScreen3(logId) { 
            const video = this.getVideoById(this.data.currentProjectId, this.data.currentVideoId);
            if (!video || !video.logs) return;
            video.logs = video.logs.filter(l => l.id !== logId); this.saveData(); this.renderSavedLogsList();
            if(this.dom.editingLogIdInput.value === logId) { this.resetLogForm(); }
            this.showToast("Log entry deleted.", "success");
        },

        showModal(modalId) { 
            const modal = document.getElementById(modalId); 
            if (modal) {
                this.data.previouslyFocusedElement = document.activeElement;
                modal.style.display = 'flex'; 
                requestAnimationFrame(() => {
                    const firstFocusable = modal.querySelector('input:not([type="hidden"]), button, [href], select, textarea, [tabindex]:not([tabindex="-1"])');
                    if (firstFocusable) firstFocusable.focus();
                });
            }
        },
        hideModal(modalId) { 
            const modal = document.getElementById(modalId); 
            if (modal) modal.style.display = 'none'; 
            if (this.data.previouslyFocusedElement) {
                try { this.data.previouslyFocusedElement.focus(); } catch(e) { /* Element might no longer be focusable */ }
                this.data.previouslyFocusedElement = null;
            }
        },
        showToast(message, type = 'info', duration = 4000) { 
            if (!this.dom.toastContainer) { 
                this.dom.toastContainer = document.getElementById('toast-container');
                if (!this.dom.toastContainer) {
                    console.error("Toast container not found!", {message, type}); return;
                }
            }
            const toast = document.createElement('div');
            toast.className = `toast-message ${type}`;
            toast.textContent = message; 
            toast.setAttribute('role', type === 'error' || type === 'warning' ? 'alert' : 'status'); 
            
            // Limit number of toasts to prevent overflow, e.g., max 5
            const MAX_TOASTS = 5;
            while (this.dom.toastContainer.children.length >= MAX_TOASTS) {
                this.dom.toastContainer.removeChild(this.dom.toastContainer.firstChild);
            }
            
            this.dom.toastContainer.appendChild(toast);
            requestAnimationFrame(() => { 
                toast.classList.add('show');
            });
            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => {
                    if (toast.parentNode === this.dom.toastContainer) { 
                         this.dom.toastContainer.removeChild(toast);
                    }
                }, { once: true });
            }, duration);
        },
        showConfirmationModal(message, onConfirm, onCancel = null, confirmButtonText = 'Confirm', confirmButtonClass = 'button-danger', title = 'Confirm Action') { 
            const modal = this.dom.modals.confirmAction;
            if (!modal) { console.error("Confirmation modal not found."); return; }

            modal.querySelector('.modal-title').textContent = title;
            this.dom.confirmActionMessage.innerHTML = message; 
            
            // Recreate buttons to ensure clean event listeners
            const oldConfirmBtn = this.dom.btnConfirmActionConfirm;
            const newConfirmBtn = oldConfirmBtn.cloneNode(true);
            newConfirmBtn.textContent = confirmButtonText;
            newConfirmBtn.className = `button ${confirmButtonClass}`;
            oldConfirmBtn.parentNode.replaceChild(newConfirmBtn, oldConfirmBtn);
            this.dom.btnConfirmActionConfirm = newConfirmBtn;

            const oldCancelBtn = this.dom.btnConfirmActionCancel;
            const newCancelBtn = oldCancelBtn.cloneNode(true);
            oldCancelBtn.parentNode.replaceChild(newCancelBtn, oldCancelBtn);
            this.dom.btnConfirmActionCancel = newCancelBtn;
            
            const confirmHandler = () => {
                onConfirm();
                this.hideModal('modal-confirm-action');
            };
            const cancelHandler = () => {
                if (onCancel) onCancel();
                this.hideModal('modal-confirm-action');
            };
            
            this.dom.btnConfirmActionConfirm.addEventListener('click', confirmHandler, {once: true}); // Use once to auto-remove
            this.dom.btnConfirmActionCancel.addEventListener('click', cancelHandler, {once: true}); // Use once to auto-remove
            
            this.showModal('modal-confirm-action');
        },
    };

    document.addEventListener('DOMContentLoaded', () => {
        try {
            app.init();
        } catch (e) {
            console.error("Critical error during app initialization:", e);
            // Display a user-friendly message on the page itself if init fails catastrophically
            const body = document.body;
            body.innerHTML = `<div style="padding: 20px; text-align: center; color: red;">
                                <h1>Application Error</h1>
                                <p>A critical error occurred and the application cannot start. Please try refreshing the page, or contact support if the problem persists.</p>
                                <p>Details: ${app.utils.escapeHtml(e.message)}</p>
                              </div>`;
        }
    });
    </script>
</body>
</html>
