<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CreateMode - Goalio Edition</title>
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="icon" href="./icon-192x192.png" type="image/png">
    <link rel="shortcut icon" href="./icon-192x192.png" type="image/png">
    <link rel="apple-touch-icon" href="./icon-192x192.png">
    <link rel="manifest" href="./manifest.webmanifest">
    
    <style>
        :root {
            --primary-color: #0f172a; 
            --primary-hover: #1e293b; 
            --warning-color: #ef4444; 
            --info-color: #3b82f6; 
            --star-important-color: #facc15; /* For priority star */
            --success-color: #22c55e; /* For success states/toasts */
            --bg-color: #f8fafc;
            --text-color: #0f172a; 
            --text-light: #64748b; 
            --card-bg: #ffffff;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --border-color: #e2e8f0; 
            --input-bg: #ffffff; /* For inputs */
            
            --quest-done-bg: #eef2ff; 
            --quest-done-text: var(--primary-color);
            --quest-overdue-border: var(--warning-color); 
            --disabled-opacity: 0.6;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; } 

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            font-size: 15px;
        }
        
        /* --- APP HEADER (Goalio Style) --- */
        .app-header {
            background-color: var(--card-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1000; 
            box-shadow: var(--shadow);
        }
        .app-header-title {
            font-size: 1.5em; /* Goalio h3ish size */
            font-weight: 600;
            color: var(--primary-color);
            text-align: center;
            flex-grow: 1;
        }
        .app-header-actions button {
            background: transparent;
            border: none;
            color: var(--primary-color);
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.1rem; /* Adjust icon size */
            width: 2.5rem; height: 2.5rem;
            display: flex; align-items: center; justify-content: center;
            transition: background-color 0.2s ease-in-out;
        }
        .app-header-actions button:hover {
            background-color: #f1f5f9; /* Light hover from Goalio */
        }
        .app-header-actions .left-action { margin-right: auto; }
        .app-header-actions .right-action { margin-left: auto; }

        .container-wrapper { /* Replaces app-container-wrapper */
            max-width: 900px; /* Consistent with Goalio but slightly wider for CreateMode needs */
            margin: 1rem auto;
            padding: 0 1rem; /* Add horizontal padding */
        }
        
        /* Top Info Area (Dashboard + Calendar + Notices) */
        .top-info-area {
            border-radius: 1rem; padding: 1rem; margin-bottom: 1.5rem;
            border: 1px solid var(--border-color); 
            background-color: var(--card-bg);
            box-shadow: var(--shadow);
        }
        .top-info-grid {
            display: grid; grid-template-columns: 1fr; 
            gap: 1rem; 
        }
        @media (min-width: 700px) { /* Adjust breakpoint as needed */
            .top-info-grid { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
        }

        .dashboard-metrics-container { /* Wrapper for CreateMode dashboard items */
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.75rem;
            /* No border/bg here, individual items get styled */
        }

        .info-item, .dashboard-metric-item { /* Unified style for notices and dashboard items */
            padding: 0.75rem 1rem; border-radius: 0.5rem; border: 1.5px solid var(--border-color);
            background-color: var(--card-bg); /* Use card-bg or a slightly different one like #f9fafb */
        }
        .info-item h4, .dashboard-metric-item .metric-title { 
            font-size: 0.8rem; font-weight: 600; margin-bottom: 0.25rem; color: var(--text-light);
        }
        .info-item p, .dashboard-metric-item .metric-value { 
            color: var(--text-color); font-size: 1.1rem; font-weight: 600; /* Made value larger */
        }
        #clearDataNotification {
            grid-column: 1 / -1; 
            background-color: #fffbeb; /* Lighter yellow for warning */
            color: #b45309; 
            padding: 0.75rem 1rem; border: 1.5px solid #fef3c7;
            border-radius: 0.5rem; font-size: 0.9em;
            display: flex; justify-content: space-between; align-items: center;
            flex-wrap: wrap; gap: 10px;
        }
        #clearDataNotification i { color: #d97706; margin-right: 0.5rem; }
        #clearDataNotification button {
            font-size: 0.85em; background-color: var(--star-important-color);
            color: var(--text-color); border: 1px solid #f59e0b;
            padding: 0.4rem 0.8rem; border-radius: 0.3rem;
        }
        #clearDataNotification button:hover { background-color: #f59e0b; }


        /* Week Calendar Styles (Adapted from Goalio Calendar) */
        .week-calendar-container {
            padding: 0.75rem; border: 1.5px solid var(--border-color); 
            border-radius: 0.5rem; background-color: var(--card-bg);
        }
        .week-calendar-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 1rem; padding: 0 0.1rem;
        }
        .week-calendar-header button {
            background: transparent; border: none; color: var(--primary-color);
            padding: 0.4rem; border-radius: 50%; cursor: pointer;
            font-size: 0.9rem; width: 2rem; height: 2rem;
            display: flex; align-items: center; justify-content: center;
            transition: background-color 0.2s ease-in-out;
        }
        .week-calendar-header button:hover { background-color: #f1f5f9; }
        .week-calendar-month-year { font-size: 1.1rem; font-weight: 600; color: var(--primary-color); }
        
        .week-calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; }
        .week-calendar-day-name-row { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; margin-bottom: 0.5rem;}

        .week-calendar-day, .week-calendar-day-name {
            text-align: center; padding: 0.5rem 0.2rem; font-size: 0.85rem;
            border-radius: 0.375rem; 
        }
        .week-calendar-day-name { font-weight: 500; color: var(--text-light); }
        .week-calendar-day {
            cursor: default; border: 1px solid transparent; 
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            min-height: 2.2rem; /* Ensure consistent height */
            display: flex; align-items: center; justify-content: center;
        }
        .week-calendar-day.other-month { color: #cbd5e1; font-weight: 300; } 
        .week-calendar-day.current-day {
            background-color: var(--primary-color); color: white; font-weight: bold;
            border-color: var(--primary-hover);
        }
        .week-calendar-day:not(.current-day):hover {
            background-color: #f8fafc; border-color: var(--border-color);
        }


        /* Quest Section (Goalio: .goal-section) */
        .quest-list-section {
            background: var(--card-bg); border-radius: 1rem; padding: 1.25rem;
            margin-bottom: 2rem; box-shadow: var(--shadow); border: 1px solid var(--border-color);
        }
        .quest-list-section-header { /* For "Active", "Completed", "Archived" titles */
            font-size: 1.25rem; color: var(--primary-color);
            display: flex; align-items: center; justify-content: center; /* Center title */
            gap: 0.5rem; margin-bottom: 1rem; padding-bottom: 0.75rem; 
            border-bottom: 2px solid var(--primary-color); 
        }
         .quest-list-section-header .toggle-section-button { /* For completed/archived expand buttons */
            background: transparent; border: none; color: var(--text-light);
            padding: 0.4rem; border-radius: 50%; cursor: pointer;
            font-size: 0.9rem; width: 2rem; height: 2rem;
            display: flex; align-items: center; justify-content: center;
            transition: color 0.2s ease-in-out;
        }
        .quest-list-section-header .toggle-section-button:hover { color: var(--primary-color); }


        /* Quest Cards (Goalio: .goal-card) */
        .quests-list { display: flex; flex-direction: column; gap: 1rem; }
        .quest-card {
            border: 1px solid var(--border-color); border-radius: 0.75rem;
            padding: 1.25rem; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.04); 
            display: flex; flex-direction: column;
            background-color: var(--card-bg); 
            position: relative;
        }
        
        .quest-card.completed-quest {
            background-color: var(--quest-done-bg); 
            transition: background-color 0.3s ease-in-out;
            opacity: 0.85; /* Slightly less opaque than goalio's done */
        }
        .quest-card.completed-quest .quest-title-text,
        .quest-card.completed-quest .quest-deadline-text {
            color: var(--quest-done-text); text-decoration: line-through; opacity: 0.7;
        }
        .quest-card.archived-quest {
            border-left: 4px solid var(--text-light); /* Distinct archived indicator */
            opacity: 0.7;
        }
        .quest-card.is-overdue:not(.completed-quest) { /* For overdue quests */
            border-left: 4px solid var(--quest-overdue-border); 
        }
        
        /* Quest Card Header area */
        .quest-card-header { /* Combines .quest-card-main-info and .quest-card-actions */
            display: flex; align-items: flex-start; /* Align checkbox with title */
            margin-bottom: 0.75rem; 
            gap: 0.5rem;
        }
        .quest-card-header .quest-complete-checkbox {
            margin-top: 0.3rem; /* Align with text better */
            transform: scale(1.2);
            accent-color: var(--primary-color);
        }
        .quest-title-text {
            font-size: 1.15rem; font-weight: 600; color: var(--text-color); 
            margin-right: 0.5rem; flex-grow: 1;
            cursor: pointer;
        }
        .quest-title-text:hover { color: var(--primary-hover); }

        .quest-card-action-buttons { /* Container for priority, expand, more_actions */
            display: flex; gap: 0.25rem; margin-left: auto; align-items: center;
        }
        .quest-card-action-buttons .btn-icon-only { /* General style for icon buttons in card */
            background: transparent; border: 1px solid transparent; 
            color: var(--text-light); 
            padding: 0.3rem; border-radius: 50%; cursor: pointer;
            font-size: 0.9rem; transition: background-color 0.2s, color 0.2s;
            width: 1.8rem; height: 1.8rem; 
            display: inline-flex; align-items: center; justify-content: center;
        }
        .quest-card-action-buttons .btn-icon-only:hover { background-color: #e5e7eb; color: var(--text-color); }
        .quest-card-action-buttons .priority-button.prioritized i { color: var(--star-important-color); }


        .quest-more-actions-container { position: relative; }
        .actions-dropdown {
            display: none; position: absolute;
            right: 0; top: 100%; 
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem; /* Goalio modal style */
            box-shadow: var(--shadow);
            z-index: 10; min-width: 180px;
            padding: 0.5rem 0;
        }
        .actions-dropdown button {
            display: flex; align-items: center; gap: 0.75rem; 
            width: 100%; padding: 0.6rem 1rem;
            text-align: left; background: none; border: none;
            color: var(--text-color); font-size: 0.9em; border-radius: 0;
            transition: background-color 0.2s;
        }
        .actions-dropdown button:hover { background-color: #f1f5f9; }
        .actions-dropdown button i { width: 1em; margin-right: 0.25rem; color: var(--text-light); }
        .actions-dropdown button.danger { color: var(--warning-color); }
        .actions-dropdown button.danger i { color: var(--warning-color); }
        .actions-dropdown button.danger:hover { background-color: #fee2e2; } /* Light red hover */
        

        /* Quest Card Meta (Deadline, Countdown, Value) */
        .quest-card-meta {
            font-size: 0.8rem; color: var(--text-light); 
            margin-bottom: 0.85rem; 
            display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; 
            border-bottom: 1px solid var(--border-color); /* Separator like Goalio */
            padding-bottom: 0.75rem;
        }
        .quest-deadline-details { display: flex; align-items: center; gap: 0.5rem; }
        .quest-deadline-details .fa-calendar-alt { font-size: 0.8rem; }
        .quest-deadline-text { font-weight: 500; }
        
        .quest-countdown { 
            font-weight: 500; display: flex; align-items: center; gap: 0.2rem; 
        }
        .quest-countdown .fa-hourglass-half { font-size: 0.8rem; }
        .quest-countdown-text { font-size: 0.8rem; }
        .quest-countdown.overdue .quest-countdown-text { color: var(--warning-color); font-weight: 600; }
        .quest-countdown.today .quest-countdown-text { color: var(--info-color); font-weight: 600; }

        .quest-value-display { font-weight: 500; font-size: 0.8rem; }
        .quest-value-display .fa-coins { font-size: 0.8rem; color: var(--star-important-color); }


        /* Quest Card Progress Bar */
        .quest-progress-wrapper { 
            display: flex; align-items: center; gap: 0.5rem; 
            margin-top: 0.5rem; margin-bottom: 0.85rem; 
        }
        .quest-progress-bar-container {
            flex-grow: 1; height: 8px; /* Slimmer bar */
            background-color: var(--border-color);
            border-radius: 4px; overflow: hidden;
        }
        .quest-progress-fill {
            height: 100%; background-color: var(--info-color); /* Use info color for progress */
            border-radius: 4px; transition: width 0.3s ease;
        }
        .quest-progress-value-text { 
            font-size: 0.8rem; color: var(--text-light);
            font-weight: 500; white-space: nowrap; flex-shrink: 0; 
        }

        /* Tasks Container (Goalio style) */
        .tasks-container {
            padding-left: 0; /* No indent */
            max-height: 0;
            overflow-y: auto;
            transition: max-height 0.3s ease-out, padding-top 0.3s ease-out, margin-top 0.3s ease-out;
            margin-top: 0; padding-top: 0;
            scrollbar-width: thin; scrollbar-color: var(--border-color) transparent;
        }
        .tasks-container::-webkit-scrollbar { width: 5px; }
        .tasks-container::-webkit-scrollbar-thumb { background-color: #d1d5db; border-radius: 3px; }

        .tasks-container.expanded {
            max-height: 350px; 
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color); 
        }
        .task-item, .subtask-item {
            display: flex; align-items: center; gap: 0.5rem;
            padding: 0.5rem 0.25rem; /* Slightly less padding */
            border-bottom: 1px solid #f1f5f9; /* Lighter separator */
        }
        .task-item:last-child, .subtask-item:last-child { border-bottom: none; }
        .subtask-item { margin-left: 1.5rem; } /* Indent subtasks */
        
        .task-item .task-checkbox, .subtask-item .subtask-checkbox {
            transform: scale(1.1); accent-color: var(--primary-color);
        }
        .task-description { flex-grow: 1; font-size: 0.9rem; }
        .task-item .task-description { font-weight: 500; } /* Main task desc slightly bolder */
        
        .task-value-chip {
            font-size: 0.75rem; font-weight: 600; color: var(--success-color);
            background-color: #dcfce7; /* Light green */
            padding: 0.15rem 0.4rem; border-radius: 10px;
            white-space: nowrap;
        }
        .task-item.completed .task-description,
        .subtask-item.completed .task-description {
            text-decoration: line-through; color: var(--text-light); opacity: 0.7;
        }

        /* Collapsible Section Wrappers */
        .collapsible-list-wrapper {
            max-height: 0; overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .collapsible-list-wrapper.expanded {
            max-height: 1500px; /* Generous height */
            margin-top: 1rem; 
            overflow-y: auto; 
        }

        /* Master Toggle for Inactive Sections (Goalio button style) */
        .inactive-sections-toggle-container {
            text-align: center;
            margin-top: 2rem; margin-bottom: 1.5rem;
        }
        #toggleInactiveSectionsBtn {
            background: var(--primary-color); color: white; border: none;
            padding: 0.6rem 1.2rem; border-radius: 0.5rem;
            cursor: pointer; font-weight: 500; font-size: 0.9rem;
            display: inline-flex; align-items: center; gap: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        #toggleInactiveSectionsBtn:hover { background: var(--primary-hover); }
        #toggleInactiveSectionsBtn i { font-size: 0.8em; } /* Smaller icon within button */

        .empty-list-message { /* Goalio .no-goals style */
           text-align: center; padding: 2rem; color: var(--text-light); 
           font-style: italic; font-size: 0.95em;
           border: 2px dashed var(--border-color);
           border-radius: 0.75rem;
           margin-top: 1rem;
           background-color: #fdfdfe; /* Very light bg */
        }
        

        /* Modals (Goalio Style) */
        .modal {
            display: none; 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.7); backdrop-filter: blur(4px);
            justify-content: center; align-items: center; z-index: 1050; padding: 1rem;
            overflow-y: auto; 
        }
        .modal-content {
            background: var(--card-bg); padding: 1.5rem; border-radius: 1rem; width: 100%;
            max-width: 550px; /* Default, can be overridden */
            box-shadow: var(--shadow); 
            margin: 2rem auto; 
        }
        .modal-header { /* Custom for CreateMode, using Goalio elements */
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 1.5rem; padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        .modal-header h2 { font-size: 1.25rem; color: var(--primary-color); margin: 0;}
        .close-modal-button {
            background: transparent; border: none; color: var(--text-light);
            padding: 0.4rem; border-radius: 50%; cursor: pointer;
            font-size: 1.1rem; width: 2.2rem; height: 2.2rem; 
            display: flex; align-items: center; justify-content: center;
            transition: background-color 0.2s, color 0.2s;
        }
        .close-modal-button:hover { background-color: #e5e7eb; color: var(--text-color); }

        .modal-body .form-group { margin-bottom: 1rem; }
        .modal-body label { display: block; margin-bottom: 0.25rem; font-size: 0.875rem; font-weight: 500; }
        .modal-body input[type="text"], .modal-body input[type="date"], 
        .modal-body input[type="number"], .modal-body select, .modal-body textarea {
            width: 100%; padding: 0.75rem; margin: 0.25rem 0 0 0; /* Removed bottom margin, handled by form-group */
            border: 1px solid var(--border-color); border-radius: 0.5rem; font-size: 0.9rem;
            background-color: var(--input-bg);
        }
        .modal-body textarea { min-height: 70px; resize: vertical; }
        .modal-body input:focus, .modal-body textarea:focus, .modal-body select:focus {
            outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(15, 23, 42, 0.1);
        }
        .modal-body h3 { /* For "Tasks for this Quest/Template" */
            margin-top: 1.5rem; margin-bottom: 0.75rem; font-size: 1.1rem; color: var(--primary-color);
        }
        .modal-body h4 { /* For "Existing Templates" */
             margin-top: 1.5rem; margin-bottom: 0.75rem; font-size: 1rem; color: var(--primary-color);
        }


        /* Task editor in Modals (Goalio style) */
        .task-editor-item {
            border: 1px solid var(--border-color);
            padding: 0.75rem; margin-bottom: 0.75rem;
            border-radius: 0.5rem;
            background-color: #f9fafb; /* Slightly different bg for nesting */
        }
        .task-editor-header { display: flex; gap: 0.5rem; align-items: center; }
        .task-editor-header input[type="text"] { flex-grow: 1; margin-bottom: 0; }
        .task-editor-header .btn-icon-only { /* Standardized icon button */
            background: transparent; border: 1px solid transparent; 
            color: var(--text-light); padding: 0.4rem; border-radius: 0.3rem; cursor: pointer;
            font-size: 0.9rem; transition: background-color 0.2s, color 0.2s;
            width: 2rem; height: 2rem; 
            display: inline-flex; align-items: center; justify-content: center;
        }
        .task-editor-header .btn-icon-only:hover { background-color: #e5e7eb; }
        .task-editor-header .btn-icon-only.danger:hover { color: var(--warning-color); }


        .subtask-editor-item {
            margin-left: 1.25rem; margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center;
        }
        .subtask-editor-item input[type="text"] { flex-grow: 1; margin-bottom: 0; }
        
        .modal-footer { 
            display: flex; justify-content: flex-end; gap: 0.75rem; 
            margin-top: 1.5rem; padding-top: 1rem; 
            border-top: 1px solid var(--border-color); 
        }
        .modal-footer button { /* Base style for modal buttons */
            padding: 0.6rem 1.2rem; border: none; border-radius: 0.5rem;
            cursor: pointer; font-weight: 500; font-size: 0.875rem;
            display: inline-flex; align-items: center; gap: 0.5rem;
        }
        .modal-footer .btn-primary { background: var(--primary-color); color: white; }
        .modal-footer .btn-primary:hover { background: var(--primary-hover); }
        .modal-footer .btn-secondary, /* For cancel buttons, etc. */
        .modal-footer .button { 
            background: #e2e8f0; color: var(--text-light); 
        }
        .modal-footer .btn-secondary:hover,
        .modal-footer .button:hover {
            background: #cbd5e1; color: var(--text-color);
        }
        .modal-footer .btn-danger { background-color: var(--warning-color); color: white; }
        .modal-footer .btn-danger:hover { background-color: #d03838; }


        /* Settings Modal Specifics */
        #settingsModal .modal-content { max-width: 700px; }
        .settings-section {
            margin-bottom: 1.5rem; padding-bottom: 1.5rem;
            border-bottom: 1px dashed var(--border-color);
        }
        .settings-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        
        #templateList .template-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.75rem 1rem; border: 1px solid var(--border-color);
            border-radius: 0.5rem; margin-bottom: 0.5rem;
            background-color: var(--input-bg);
        }
        #templateList .template-item.default-template { 
            border-left: 3px solid var(--star-important-color); 
            font-weight: 500; background-color: #fffbeb; /* Light yellow bg for default */
        }
        #templateList .template-item span { flex-grow: 1; }
        #templateList .template-item .template-actions { display: flex; gap: 0.3rem; }
        #templateList .template-item .template-actions button { /* Smaller buttons for template list */
            font-size: 0.8em; padding: 0.4rem 0.6rem; border-radius: 0.3rem;
        }
         /* For "Add Main Task" / "New Template" buttons in modals */
        .btn-modal-utility {
            background: #f1f5f9; color: var(--primary-color); border: 1px solid var(--border-color);
            padding: 0.5rem 1rem; border-radius: 0.5rem;
            cursor: pointer; font-weight: 500; font-size: 0.875rem;
            display: inline-flex; align-items: center; gap: 0.5rem;
            transition: background-color 0.2s;
        }
        .btn-modal-utility:hover { background-color: #e2e8f0; }


        /* Toast Notifications (Goalio Style) */
        #toastContainer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2000; 
            display: flex;
            flex-direction: column-reverse; 
            gap: 10px;
            max-width: 350px;
        }
        .toast-message {
            padding: 1rem 1.25rem; /* More padding */
            border-radius: 0.5rem; /* Consistent radius */
            color: white; /* Default text color on accent */
            font-size: 0.95em;
            box-shadow: var(--shadow);
            opacity: 0; 
            word-wrap: break-word;
            animation-name: toastFadeIn, toastFadeOut;
            animation-duration: 0.3s, 0.3s; 
            animation-fill-mode: forwards, forwards;
            animation-timing-function: ease-out, ease-in;
            animation-delay: 0s, var(--toast-visible-duration, 3000ms); 
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .toast-message i { font-size: 1.2em; /* Larger icon */ }
        .toast-message.success { background-color: var(--success-color); }
        .toast-message.info { background-color: var(--info-color); }
        .toast-message.warning { background-color: var(--star-important-color); color: var(--text-color); }
        .toast-message.error { background-color: var(--warning-color); }

        @keyframes toastFadeIn {
            from { opacity: 0; transform: translateX(100%); } /* Slide in from right */
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes toastFadeOut {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100%); } /* Slide out to right */
        }
        
        /* Animation for quest card exiting (deletion) */
        .quest-card.exiting {
            animation: fadeOutCollapseQuest 0.35s ease-out forwards;
        }
        @keyframes fadeOutCollapseQuest { /* Adapted from Goalio */
            0% {
                opacity: 1; transform: translateX(0) scale(1);
                max-height: 400px; /* Estimate; adjust if cards can be taller */
                padding-top: 1.25rem; padding-bottom: 1.25rem;
                margin-bottom: 1rem; 
                border-width: 1px;
            }
            to {
                opacity: 0; transform: translateX(-50px) scale(0.9);
                max-height: 0; padding-top: 0; padding-bottom: 0;
                margin-bottom: 0; border-width: 0; overflow: hidden;
            }
        }
        /* Initial state for new card appearance animation */
        .quest-card.entering {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }


        /* --- RESPONSIVE ADJUSTMENTS (Goalio Inspired) --- */
        @media (max-width: 768px) {
            body { font-size: 14px; }
            .app-header-title { font-size: 1.3em; }
            .container-wrapper { padding: 0 0.75rem; }
            
            .top-info-grid { grid-template-columns: 1fr; } /* Stack earlier */
            .dashboard-metrics-container { grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); }
            .info-item p, .dashboard-metric-item .metric-value { font-size: 1rem; }

            .quest-title-text { font-size: 1.05em; }
            .quest-card-meta { font-size: 0.75rem; }
            .modal-content { margin: 5% auto; width: 95%; padding: 1.25rem; }
            .modal-header h2 { font-size: 1.15rem; }
            #toastContainer { right: 10px; bottom: 10px; max-width: calc(100% - 20px); }
        }

        @media (max-width: 480px) {
            .app-header { padding: 0.5rem 0.75rem; }
            .app-header-actions button { width: 2.2rem; height: 2.2rem; font-size: 1rem;}
            .dashboard-metrics-container { grid-template-columns: 1fr; } /* Single column for dashboard items */
            
            .quest-card-header { flex-wrap: wrap; }
            .quest-card-action-buttons { width: 100%; justify-content: flex-end; margin-top: 0.5rem; }
            .quest-card-meta { flex-direction: column; align-items: flex-start; gap: 0.5rem; }
            .subtask-item { margin-left: 1rem; }
        }

    </style>
</head>
<body>
    <header class="app-header">
        <div class="app-header-actions left-action">
            <button id="addQuestHeaderBtn" title="Start New Quest" aria-label="Start New Quest">
                <i class="fas fa-plus-circle"></i>
            </button>
        </div>
        <h1 class="app-header-title">CreateMode</h1>
        <div class="app-header-actions right-action">
            <button id="settingsHeaderBtn" title="Settings" aria-label="Settings">
                <i class="fas fa-cog"></i>
            </button>
        </div>
    </header>

    <div class="container-wrapper">
        <!-- Top Info Area: Dashboard, Week Calendar, Notices -->
        <div class="top-info-area">
            <div class="top-info-grid">
                <div class="dashboard-metrics-container" id="dashboardMetricsHost">
                    <!-- Dashboard metrics will be moved here by JS -->
                </div>
                <div class="week-calendar-container" id="weekCalendarContainer">
                    <!-- Week calendar will be injected here -->
                </div>
                <div class="info-item"><h4>Weeks Left (Month)</h4><p id="weeksLeftMonth">-</p></div>
                <div class="info-item"><h4>Months Left (Year)</h4><p id="monthsLeftYear">-</p></div>
            </div>
            <div id="clearDataNotification" style="display: none; margin-top: 1rem;">
                <span><i class="fas fa-info-circle"></i> Keep things lean! Old project data from previous months can be cleared in Settings.</span>
                <button id="goToSettingsFromNotification" aria-label="Go to Settings to clear data">Go to Settings</button>
            </div>
        </div>
        
        <!-- Hidden Original Dashboard (items will be moved by JS) -->
        <div class="dashboard" id="originalDashboardSource" style="display:none;">
            <div class="dashboard-metric-item">
                <div class="metric-title">Earnings Today</div>
                <p class="metric-value" id="valueToday">$0</p>
            </div>
            <div class="dashboard-metric-item">
                <div class="metric-title">Earnings This Month</div>
                <p class="metric-value" id="valueMonth">$0</p>
            </div>
            <div class="dashboard-metric-item">
                <div class="metric-title">Upcoming Value</div>
                <p class="metric-value" id="upcomingValue">$0</p>
            </div>
        </div>


        <!-- Active Quests -->
        <div class="quest-list-section">
            <h2 class="quest-list-section-header"><i class="fas fa-rocket" style="margin-right: 0.5rem;"></i> Active Quests</h2>
            <div id="activeQuestsList" class="quests-list">
                <!-- Quest cards will be injected here -->
            </div>
        </div>

        <!-- Master Toggle for Inactive Sections -->
        <div class="inactive-sections-toggle-container">
            <button id="toggleInactiveSectionsBtn" aria-label="Toggle visibility of completed and archived sections">
                <i class="fas fa-chevron-down" id="inactiveSectionsToggleIcon"></i>
                <span id="inactiveSectionsToggleText">Show Completed & Archived</span>
            </button>
        </div>

        <!-- Completed Quests -->
        <div class="quest-list-section" id="completedSectionContainer" style="display:none;">
            <h2 class="quest-list-section-header">
                <span class="completed-section-title-text"><i class="fas fa-check-circle" style="margin-right: 0.5rem; color: var(--success-color);"></i>Completed (This Month)</span>
                <button id="toggleCompletedListBtn" class="toggle-section-button" title="Toggle Completed Quests View" aria-label="Toggle Completed Quests View">
                    <i class="fas fa-chevron-down"></i>
                </button>
            </h2>
            <div id="completedQuestsListWrapper" class="collapsible-list-wrapper">
                <div id="completedQuestsList" class="quests-list"></div>
            </div>
        </div>

        <!-- Archived Quests -->
        <div class="quest-list-section" id="archivedSectionContainer" style="display:none;">
            <h2 class="quest-list-section-header">
                <span class="archived-section-title-text"><i class="fas fa-archive" style="margin-right: 0.5rem; color: var(--text-light);"></i>Archived</span>
                <button id="toggleArchivedListBtn" class="toggle-section-button" title="Toggle Archived Quests View" aria-label="Toggle Archived Quests View">
                    <i class="fas fa-chevron-down"></i>
                </button>
            </h2>
            <div id="archivedQuestsListWrapper" class="collapsible-list-wrapper">
                <div id="archivedQuestsList" class="quests-list"></div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Quest Modal -->
    <div id="questModal" class="modal" aria-modal="true" aria-labelledby="questModalTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="questModalTitle">Start New Quest</h2>
                <button class="close-modal-button" id="closeQuestModal" title="Close Quest Modal" aria-label="Close Quest Modal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="questId">
                <div class="form-group">
                    <label for="questTitle">Quest Title (Video Title):</label>
                    <input type="text" id="questTitle" placeholder="E.g., My Awesome Cat Video">
                </div>
                <div class="form-group">
                    <label for="questDeadline">Deadline:</label>
                    <input type="date" id="questDeadline">
                </div>
                <div class="form-group">
                    <label for="questValueInput">Total Value for this Quest ($):</label>
                    <input type="number" id="questValueInput" placeholder="E.g., 100" min="0">
                </div>
                <div class="form-group">
                    <label for="questTemplateSelect">Use Template:</label>
                    <select id="questTemplateSelect"></select>
                </div>
                
                <h3><i class="fas fa-tasks" style="margin-right: 0.5rem;"></i>Tasks for this Quest:</h3>
                <div id="modalTasksContainer">
                    <!-- Tasks will be dynamically added here -->
                </div>
                <button id="addModalMainTaskBtn" class="btn-modal-utility" style="margin-top:10px;">
                    <i class="fas fa-plus-circle"></i> Add Main Task
                </button>
            </div>
            <div class="modal-footer">
                <button type="button" class="button" id="cancelQuestModalBtn">Cancel</button> <!-- Added cancel button -->
                <button id="saveQuestBtn" class="btn-primary">
                    <i class="fas fa-save"></i> Save Quest
                </button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal" aria-modal="true" aria-labelledby="settingsModalTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="settingsModalTitle"><i class="fas fa-cog" style="margin-right: 0.5rem;"></i>Settings</h2>
                <button class="close-modal-button" id="closeSettingsModal" title="Close Settings Modal" aria-label="Close Settings Modal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <h3><i class="fas fa-clipboard-list" style="margin-right: 0.5rem;"></i>Quest Templates</h3>
                    <div id="templateEditor">
                        <input type="hidden" id="templateId">
                        <div class="form-group">
                            <label for="templateName">Template Name:</label>
                            <input type="text" id="templateName" placeholder="E.g., Standard Video, Quick Vlog">
                        </div>
                        <h4><i class="fas fa-tasks" style="margin-right: 0.5rem;"></i>Tasks for this Template:</h4>
                        <div id="templateTasksContainer"></div>
                        <button id="addTemplateMainTaskBtn" class="btn-modal-utility" style="margin-top:10px;">
                             <i class="fas fa-plus-circle"></i> Add Main Task
                        </button>
                        <div style="margin-top: 20px; display:flex; gap: 10px;">
                            <button id="saveTemplateBtn" class="btn-primary">
                                <i class="fas fa-save"></i> Save Template
                            </button>
                            <button id="newTemplateBtn" class="btn-modal-utility" style="margin-left: auto;">
                                <i class="fas fa-file-alt"></i> New Template
                            </button>
                        </div>
                    </div>
                    <h4 style="margin-top: 30px;"><i class="fas fa-list-alt" style="margin-right: 0.5rem;"></i>Existing Templates:</h4>
                    <div id="templateList"></div>
                </div>

                <div class="settings-section">
                    <h3><i class="fas fa-database" style="margin-right: 0.5rem;"></i>Data Management</h3>
                    <p>Permanently delete all project data (titles, tasks, value) for quests completed <strong>before the current month</strong>. This action cannot be undone.</p>
                    <button id="clearOldDataBtn" class="btn-danger" style="margin-top:15px;">
                        <i class="fas fa-trash-alt"></i> Clear Old Project Data
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Custom Confirm Modal -->
    <div id="customConfirmModal" class="modal" aria-modal="true" aria-labelledby="customConfirmModalTitle">
        <div class="modal-content" style="max-width: 480px;">
            <div class="modal-header">
                <h2 id="customConfirmModalTitle"><i class="fas fa-exclamation-triangle" style="margin-right:0.5rem; color: var(--warning-color);"></i>Confirm Action</h2>
            </div>
            <div class="modal-body">
                <p id="customConfirmModalMessage" style="line-height: 1.6; font-size: 0.95rem;">Are you sure?</p>
            </div>
            <div class="modal-footer">
                <button id="customConfirmModalCancelBtn" class="button">Cancel</button>
                <button id="customConfirmModalConfirmBtn" class="btn-danger">Confirm</button>
            </div>
        </div>
    </div>

    <div id="toastContainer"></div>

    <script>
        // --- APP STATE & LOCAL STORAGE (FROM CREATEMODE) ---
        let appData = { projects: [], templates: [] };
        const APP_DATA_KEY = 'creatorQuestLogData_v3_goalio'; // New key for reskinned version
        let inactiveSectionsVisible = false;
        const INACTIVE_SECTIONS_VISIBILITY_KEY = 'creatorQuestLog_inactiveSectionsVisibility_v1_goalio';
        let currentCalendarDate = new Date(); // For week calendar

        // --- DOM Elements (Goalio Style) ---
        const weekCalendarContainer = document.getElementById('weekCalendarContainer');
        const weeksLeftMonthEl = document.getElementById('weeksLeftMonth');
        const monthsLeftYearEl = document.getElementById('monthsLeftYear');

        // --- calculateDaysLeft (from Goalio, adapted for Quests) ---
        function calculateQuestDaysLeft(deadlineString) {
            if (!deadlineString) return { deadlineFormatted: 'No Deadline', countdownText: '', days: Infinity, isOverdue: false, isToday: false };

            const deadlineDate = new Date(deadlineString + 'T00:00:00Z'); // UTC for consistency
            const deadlineFormatted = deadlineDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', timeZone: 'UTC' });
            
            const now = new Date();
            const today = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
            
            const diffTime = deadlineDate.getTime() - today.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            let countdownText = "";
            let isOverdue = false;
            let isToday = false;

            if (diffDays < 0) {
                countdownText = `${Math.abs(diffDays)} day${Math.abs(diffDays) !== 1 ? 's' : ''} overdue`;
                isOverdue = true;
            } else if (diffDays === 0) {
                countdownText = "Due Today";
                isToday = true;
            } else {
                countdownText = `${diffDays} day${diffDays !== 1 ? 's' : ''} left`;
            }
            return { deadlineFormatted, countdownText, days: diffDays, isOverdue, isToday };
        }
        
        // --- Week Calendar (Adapted from Goalio Calendar) ---
        function renderWeekCalendar(dateToDisplay) {
            weekCalendarContainer.innerHTML = ''; 

            const year = dateToDisplay.getFullYear();
            const month = dateToDisplay.getMonth();
            const day = dateToDisplay.getDate();

            const header = document.createElement('div');
            header.className = 'week-calendar-header';
            
            const prevButton = document.createElement('button');
            prevButton.innerHTML = '<i class="fas fa-chevron-left"></i>';
            prevButton.title = "Previous Week";
            prevButton.onclick = () => {
                currentCalendarDate.setDate(currentCalendarDate.getDate() - 7);
                renderWeekCalendar(currentCalendarDate);
            };

            const monthYearText = document.createElement('span');
            monthYearText.className = 'week-calendar-month-year';
            // Show range or current month
             const firstDayOfWeek = new Date(dateToDisplay);
             firstDayOfWeek.setDate(day - dateToDisplay.getDay()); // Assuming Sunday is the first day
             const lastDayOfWeek = new Date(firstDayOfWeek);
             lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);

            if (firstDayOfWeek.getMonth() === lastDayOfWeek.getMonth()) {
                monthYearText.textContent = `${firstDayOfWeek.toLocaleDateString('en-US', { month: 'long' })} ${year}`;
            } else {
                 monthYearText.textContent = `${firstDayOfWeek.toLocaleDateString('en-US', { month: 'short' })} - ${lastDayOfWeek.toLocaleDateString('en-US', { month: 'short' })} ${year}`;
            }


            const nextButton = document.createElement('button');
            nextButton.innerHTML = '<i class="fas fa-chevron-right"></i>';
            nextButton.title = "Next Week";
            nextButton.onclick = () => {
                currentCalendarDate.setDate(currentCalendarDate.getDate() + 7);
                renderWeekCalendar(currentCalendarDate);
            };

            header.appendChild(prevButton);
            header.appendChild(monthYearText);
            header.appendChild(nextButton);
            weekCalendarContainer.appendChild(header);

            const dayNameRow = document.createElement('div'); 
            dayNameRow.className = 'week-calendar-day-name-row';
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayNames.forEach(name => {
                const dayNameCell = document.createElement('div');
                dayNameCell.className = 'week-calendar-day-name';
                dayNameCell.textContent = name;
                dayNameRow.appendChild(dayNameCell);
            });
            weekCalendarContainer.appendChild(dayNameRow);

            const grid = document.createElement('div');
            grid.className = 'week-calendar-grid';

            const today = new Date();
            const currentWeekStart = new Date(dateToDisplay);
            currentWeekStart.setDate(dateToDisplay.getDate() - dateToDisplay.getDay()); // Start of current selected week (Sunday)

            for (let i = 0; i < 7; i++) {
                const dayCellDate = new Date(currentWeekStart);
                dayCellDate.setDate(currentWeekStart.getDate() + i);
                
                const dayCell = document.createElement('div');
                dayCell.className = 'week-calendar-day';
                dayCell.textContent = dayCellDate.getDate();
                
                if (dayCellDate.getFullYear() === today.getFullYear() && 
                    dayCellDate.getMonth() === today.getMonth() && 
                    dayCellDate.getDate() === today.getDate()) {
                    dayCell.classList.add('current-day');
                }
                // Optionally dim days not in the current month of `dateToDisplay`
                if (dayCellDate.getMonth() !== month) {
                     dayCell.classList.add('other-month');
                }
                grid.appendChild(dayCell);
            }
            weekCalendarContainer.appendChild(grid);
        }

        // --- updateNotices (from Goalio) ---
        function updateNotices() {
            const now = new Date();
            
            const lastDayOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            const daysLeftInMonth = lastDayOfMonth.getDate() - now.getDate();
            let weeksLeftText = "";

            if (daysLeftInMonth < 0) { // Should not happen with correct logic but as a fallback
                weeksLeftText = "Month ended";
            } else if (daysLeftInMonth === 0 && now.getDate() === lastDayOfMonth.getDate()) {
                weeksLeftText = "Today is last day!";
            } else {
                const fullWeeks = Math.floor(daysLeftInMonth / 7);
                const remainingDays = daysLeftInMonth % 7;
                if (fullWeeks > 0) weeksLeftText += `${fullWeeks} week${fullWeeks !== 1 ? 's' : ''}`;
                if (remainingDays > 0) weeksLeftText += `${fullWeeks > 0 ? ', ' : ''}${remainingDays} day${remainingDays !== 1 ? 's' : ''}`;
                if (weeksLeftText === "" && daysLeftInMonth > 0) weeksLeftText = `${daysLeftInMonth} day${daysLeftInMonth !== 1 ? 's' : ''}`;
                else if (weeksLeftText === "") weeksLeftText = "Final week";
            }
            weeksLeftMonthEl.textContent = weeksLeftText || "0 days";
            monthsLeftYearEl.textContent = `${11 - now.getMonth()} month${(11 - now.getMonth()) !== 1 ? 's' : ''}`;
        }


        // --- CREATEMODE SCRIPT (ADAPTED) ---
        let toggleInactiveSectionsBtn, inactiveSectionsToggleIcon, inactiveSectionsToggleText;
        let completedSectionContainer, archivedSectionContainer;

        function initializeDefaultAppState() {
             // ... (rest of CreateMode's initializeDefaultAppState)
            appData = {
                projects: [],
                templates: [{
                    id: 'default-' + Date.now(),
                    name: 'Default Video Workflow',
                    isDefault: true,
                    tasks: [
                        { id: 'dt1-' + generateId(), description: 'Ideation & Research', subtasks: [] },
                        { id: 'dt2-' + generateId(), description: 'Scripting/Outlining', subtasks: [] },
                        { id: 'dt3-' + generateId(), description: 'Filming/Recording', subtasks: [] },
                        { id: 'dt4-' + generateId(), description: 'Editing', subtasks: [{id: 'dts1-' + generateId(), description: 'Rough Cut'}, {id: 'dts2-' + generateId(), description: 'Final Polish'}] },
                        { id: 'dt5-' + generateId(), description: 'Thumbnail & SEO', subtasks: [] },
                        { id: 'dt6-' + generateId(), description: 'Upload & Publish', subtasks: [] },
                    ]
                }]
            };
        }

        function loadData() {
            // ... (rest of CreateMode's loadData, ensure APP_DATA_KEY is used)
            const storedData = localStorage.getItem(APP_DATA_KEY);
            if (storedData) {
                try {
                    appData = JSON.parse(storedData);
                    appData.projects = appData.projects || [];
                    appData.templates = appData.templates || [];

                    appData.projects.forEach(p => { 
                        p.tasks = p.tasks || [];
                        if (p.ui_isExpanded === undefined) p.ui_isExpanded = false;
                        if (p.ui_scrollPosition === undefined) p.ui_scrollPosition = 0; 
                        if (p.totalGoldValue !== undefined) { p.totalValue = p.totalGoldValue; delete p.totalGoldValue; }
                        if (p.goldEarned !== undefined) { p.valueEarned = p.goldEarned; delete p.goldEarned; }
                        
                        p.totalValue = parseFloat(p.totalValue) || 0;
                        p.valueEarned = parseFloat(p.valueEarned) || 0; 
                        if (p.isArchived === undefined) p.isArchived = false;
                        if (p.creationTimestamp === undefined) p.creationTimestamp = Date.now();

                        p.tasks.forEach(t => {
                             t.subtasks = t.subtasks || [];
                             if (t.goldValue !== undefined) { t.taskValue = t.goldValue; delete t.goldValue; }
                             t.taskValue = parseFloat(t.taskValue) || 0; 
                             t.subtasks.forEach(st => {
                                 st.subtaskValue = parseFloat(st.subtaskValue) || 0; 
                                 if (st.completionTimestamp && typeof st.completionTimestamp !== 'number') st.completionTimestamp = new Date(st.completionTimestamp).getTime();
                                 if (isNaN(st.completionTimestamp)) st.completionTimestamp = null;

                             });
                             if (t.completionTimestamp && typeof t.completionTimestamp !== 'number') t.completionTimestamp = new Date(t.completionTimestamp).getTime();
                             if (isNaN(t.completionTimestamp)) t.completionTimestamp = null;

                        });
                        distributeValueToTasks(p); 
                        let initialEarnedValue = 0;
                        p.tasks.forEach(task => {
                            if (task.subtasks.length > 0) {
                                task.subtasks.forEach(subtask => {
                                    if (subtask.isCompleted) initialEarnedValue += (parseFloat(subtask.subtaskValue) || 0);
                                });
                            } else {
                                if (task.isCompleted) initialEarnedValue += (parseFloat(task.taskValue) || 0);
                            }
                        });
                        p.valueEarned = Math.max(0, Math.min(initialEarnedValue, p.totalValue));

                         if (p.completionTimestamp && typeof p.completionTimestamp !== 'number') p.completionTimestamp = new Date(p.completionTimestamp).getTime();
                         if (isNaN(p.completionTimestamp)) p.completionTimestamp = null;

                    });
                    if (appData.templates.length === 0) {
                        appData.templates.push({
                            id: 'default-fallback-' + Date.now(), name: 'Default Video Workflow', isDefault: true,
                            tasks: [
                                { id: 'dtf1-' + generateId(), description: 'Ideation & Research', subtasks: [] },
                                { id: 'dtf2-' + generateId(), description: 'Scripting/Outlining', subtasks: [] },
                                { id: 'dtf3-' + generateId(), description: 'Filming/Recording', subtasks: [] },
                                { id: 'dtf4-' + generateId(), description: 'Editing', subtasks: [{id: 'dtfs1-' + generateId(), description: 'Rough Cut'}, {id: 'dtfs2-' + generateId(), description: 'Final Polish'}] },
                                { id: 'dtf5-' + generateId(), description: 'Thumbnail & SEO', subtasks: [] },
                                { id: 'dtf6-' + generateId(), description: 'Upload & Publish', subtasks: [] },
                            ]
                        });
                    } else if (!appData.templates.some(t => t.isDefault)) {
                        appData.templates[0].isDefault = true;
                    }

                } catch (error) {
                    console.error("Error parsing data from localStorage:", error);
                    showToast("Data load error. Resetting to defaults.", 'error', 6000);
                    localStorage.removeItem(APP_DATA_KEY); 
                    initializeDefaultAppState(); 
                    appData.projects.forEach(p => distributeValueToTasks(p));
                }
            } else { 
                initializeDefaultAppState(); 
                appData.projects.forEach(p => distributeValueToTasks(p));
            }
        }

        function saveData() {
            // ... (CreateMode's saveData)
             try {
                localStorage.setItem(APP_DATA_KEY, JSON.stringify(appData));
            } catch (error) {
                if (error.name === 'QuotaExceededError' || (error.code && (error.code === 22 || error.code === 1014))) { 
                    console.error("LocalStorage quota exceeded:", error);
                    showToast("Storage full. Cannot save. Please clear data.", 'error', 7000);
                } else {
                    console.error("Error saving data to localStorage:", error);
                    showToast("Save error. Data not saved.", 'error', 5000);
                }
            }
        }
        function generateId() { return Date.now().toString(36) + Math.random().toString(36).substr(2, 9); }
        function formatDateForDisplay(dateString) {
            if (!dateString) return 'No Deadline';
            const date = new Date(dateString);
            const adjustedDate = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
            return adjustedDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
        }
        function getTodayString() {
            const today = new Date();
            return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        }

        function showToast(message, type = 'info', durationVisible = 3000) {
            // ... (CreateMode's showToast, but adapted for Font Awesome icons and Goalio style)
            let toastContainer = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast-message ${type}`;
            let iconClass = 'fas fa-info-circle';
            if (type === 'success') iconClass = 'fas fa-check-circle';
            else if (type === 'warning') iconClass = 'fas fa-exclamation-triangle';
            else if (type === 'error') iconClass = 'fas fa-times-circle';

            toast.innerHTML = `<i class="${iconClass}"></i> <span class="toast-text-content">${message}</span>`;
            toast.style.setProperty('--toast-visible-duration', `${durationVisible}ms`);
            toastContainer.appendChild(toast); 
            const totalAnimationTime = 300 + durationVisible + 300 + 100;
            setTimeout(() => { if (toast.parentNode) { toast.remove(); } }, totalAnimationTime);
        }

        let customConfirmModal, customConfirmModalTitleEl, customConfirmModalMessageEl, customConfirmModalConfirmBtn, customConfirmModalCancelBtn;
        let currentConfirmCallback = null; let currentCancelCallback = null;

        function initCustomConfirmModal() { /* ... (CreateMode's initCustomConfirmModal) ... */ 
            customConfirmModal = document.getElementById('customConfirmModal');
            customConfirmModalTitleEl = document.getElementById('customConfirmModalTitle');
            customConfirmModalMessageEl = document.getElementById('customConfirmModalMessage');
            customConfirmModalConfirmBtn = document.getElementById('customConfirmModalConfirmBtn');
            customConfirmModalCancelBtn = document.getElementById('customConfirmModalCancelBtn');
        }
        
        function showCustomConfirm(message, title = "Confirm Action", onConfirm, onCancel = null) { /* ... (CreateMode's showCustomConfirm) ... */
            customConfirmModalMessageEl.innerHTML = message; // Allow HTML in message
            customConfirmModalTitleEl.innerHTML = `<i class="fas fa-exclamation-triangle" style="margin-right:0.5rem; color: var(--warning-color);"></i>${title}`; // Default icon
            
            currentConfirmCallback = onConfirm;
            currentCancelCallback = onCancel;

            // Re-clone buttons to ensure event listeners are fresh
            const newConfirmBtn = customConfirmModalConfirmBtn.cloneNode(true);
            customConfirmModalConfirmBtn.parentNode.replaceChild(newConfirmBtn, customConfirmModalConfirmBtn);
            customConfirmModalConfirmBtn = newConfirmBtn;

            const newCancelBtn = customConfirmModalCancelBtn.cloneNode(true);
            customConfirmModalCancelBtn.parentNode.replaceChild(newCancelBtn, customConfirmModalCancelBtn);
            customConfirmModalCancelBtn = newCancelBtn;

            customConfirmModalConfirmBtn.onclick = () => {
                customConfirmModal.style.display = 'none';
                if (currentConfirmCallback) currentConfirmCallback();
            };
            customConfirmModalCancelBtn.onclick = () => {
                customConfirmModal.style.display = 'none';
                if (currentCancelCallback) currentCancelCallback();
            };
            customConfirmModal.style.display = 'flex'; // Use flex for centering
            customConfirmModalCancelBtn.focus();
        }

        function applyInactiveSectionsVisibilityState() { /* ... (CreateMode's applyInactiveSectionsVisibilityState, but using fas icons) ... */
            if (!completedSectionContainer || !archivedSectionContainer || !inactiveSectionsToggleIcon || !inactiveSectionsToggleText) {
                return;
            }
            if (inactiveSectionsVisible) {
                completedSectionContainer.style.display = 'block';
                archivedSectionContainer.style.display = 'block';
                inactiveSectionsToggleIcon.className = 'fas fa-chevron-up';
                inactiveSectionsToggleText.textContent = 'Hide Completed & Archived';
            } else {
                completedSectionContainer.style.display = 'none';
                archivedSectionContainer.style.display = 'none';
                inactiveSectionsToggleIcon.className = 'fas fa-chevron-down';
                inactiveSectionsToggleText.textContent = 'Show Completed & Archived';
            }
            renderProjects();
        }

        function initInactiveSectionsToggle() { /* ... (CreateMode's initInactiveSectionsToggle) ... */ 
            const storedVisibility = localStorage.getItem(INACTIVE_SECTIONS_VISIBILITY_KEY);
            if (storedVisibility !== null) {
                inactiveSectionsVisible = JSON.parse(storedVisibility);
            }
            applyInactiveSectionsVisibilityState(); 
            toggleInactiveSectionsBtn.addEventListener('click', () => {
                inactiveSectionsVisible = !inactiveSectionsVisible;
                localStorage.setItem(INACTIVE_SECTIONS_VISIBILITY_KEY, JSON.stringify(inactiveSectionsVisible));
                applyInactiveSectionsVisibilityState(); 
            });
        }

        function updateDashboard() { /* ... (CreateMode's updateDashboard) ... */ 
            let valueToday = 0, valueMonth = 0, upcomingValueTotal = 0;
            const todayDate = new Date(); todayDate.setHours(0, 0, 0, 0); 
            const firstDayOfMonth = new Date(todayDate.getFullYear(), todayDate.getMonth(), 1);

            appData.projects.forEach(project => {
                project.tasks = project.tasks || [];
                if (project.isArchived) return; 

                const totalVal = parseFloat(project.totalValue) || 0;
                const earnedVal = parseFloat(project.valueEarned) || 0;

                if (!project.isCompleted) { 
                    upcomingValueTotal += (totalVal - earnedVal); 
                }
                
                project.tasks.forEach(task => {
                    task.subtasks = task.subtasks || [];
                    if (task.subtasks.length > 0) {
                        task.subtasks.forEach(subtask => {
                            if (subtask.isCompleted && subtask.completionTimestamp) {
                                const subtaskCompletionDate = new Date(subtask.completionTimestamp);
                                subtaskCompletionDate.setHours(0,0,0,0);
                                const subtaskVal = parseFloat(subtask.subtaskValue) || 0;
                                if (subtaskCompletionDate.getTime() === todayDate.getTime()) { valueToday += subtaskVal; }
                                if (subtaskCompletionDate >= firstDayOfMonth) { valueMonth += subtaskVal; }
                            }
                        });
                    } else { 
                        if (task.isCompleted && task.completionTimestamp) {
                            const taskCompletionDate = new Date(task.completionTimestamp);
                            taskCompletionDate.setHours(0,0,0,0);
                            const taskVal = parseFloat(task.taskValue) || 0;
                            if (taskCompletionDate.getTime() === todayDate.getTime()) { valueToday += taskVal; }
                            if (taskCompletionDate >= firstDayOfMonth) { valueMonth += taskVal; }
                        }
                    }
                });
            });
            document.getElementById('valueToday').textContent = `$${valueToday.toFixed(0)}`;
            document.getElementById('valueMonth').textContent = `$${valueMonth.toFixed(0)}`;
            document.getElementById('upcomingValue').textContent = `$${upcomingValueTotal.toFixed(0)}`;
            checkClearDataNotification();
        }

        // --- RENDER PROJECTS WITH FLIP (Adapted from Goalio's renderAllGoals) ---
        function renderProjects() {
            const listsToRender = [
                { el: document.getElementById('activeQuestsList'), type: 'active' },
                { el: document.getElementById('completedQuestsList'), type: 'completed' },
                { el: document.getElementById('archivedQuestsList'), type: 'archived' }
            ];

            const firstPassPositions = new Map();
            listsToRender.forEach(listInfo => {
                Array.from(listInfo.el.children).forEach(cardElement => {
                    const projectId = cardElement.dataset.id;
                    if (projectId && !cardElement.classList.contains('exiting')) {
                        firstPassPositions.set(projectId, cardElement.getBoundingClientRect());
                    }
                });
                listInfo.el.innerHTML = ''; // Clear existing content
            });
            
            const active = [], completedThisMonth = [], archived = [];
            const firstDayOfCurrentMonth = new Date();
            firstDayOfCurrentMonth.setDate(1); firstDayOfCurrentMonth.setHours(0, 0, 0, 0);

            appData.projects.forEach(project => {
                project.tasks = project.tasks || []; 
                project.tasks.forEach(t => t.subtasks = t.subtasks || []); 
                if (project.isArchived === undefined) project.isArchived = false;
                if (project.creationTimestamp === undefined) project.creationTimestamp = Date.now();

                if (project.isArchived) archived.push(project);
                else if (project.isCompleted) {
                    if (!project.completionTimestamp || new Date(project.completionTimestamp) >= firstDayOfCurrentMonth) {
                        completedThisMonth.push(project);
                    }
                } else active.push(project);
            });

            active.sort((a, b) => { /* ... CreateMode sorting ... */ 
                if (a.priority !== b.priority) return a.priority ? -1 : 1;
                const aDeadlineInfo = calculateQuestDaysLeft(a.deadline);
                const bDeadlineInfo = calculateQuestDaysLeft(b.deadline);
                if (aDeadlineInfo.days !== bDeadlineInfo.days) return aDeadlineInfo.days - bDeadlineInfo.days; // Sort by days left
                return (b.creationTimestamp || 0) - (a.creationTimestamp || 0);
            });
            completedThisMonth.sort((a, b) => (b.completionTimestamp || 0) - (a.completionTimestamp || 0));
            archived.sort((a,b) => { /* ... CreateMode sorting ... */ 
                const aSortTime = a.completionTimestamp || a.creationTimestamp || 0;
                const bSortTime = b.completionTimestamp || b.creationTimestamp || 0;
                return bSortTime - aSortTime;
            });

            const projectMap = { active, completed: completedThisMonth, archived };

            listsToRender.forEach(listInfo => {
                const projectsForList = projectMap[listInfo.type];
                if (projectsForList.length === 0 && 
                    (listInfo.type === 'active' || 
                     (listInfo.type === 'completed' && inactiveSectionsVisible && document.getElementById('completedQuestsListWrapper').classList.contains('expanded')) ||
                     (listInfo.type === 'archived' && inactiveSectionsVisible && document.getElementById('archivedQuestsListWrapper').classList.contains('expanded'))
                    )) {
                    let message = "No active quests. Time to start a new one!";
                    if (listInfo.type === 'completed') message = "No quests completed this month yet.";
                    if (listInfo.type === 'archived') message = "No archived quests.";
                    listInfo.el.innerHTML = `<p class="empty-list-message">${message}</p>`;
                } else {
                    projectsForList.forEach(project => {
                        const card = createProjectCard(project);
                        listInfo.el.appendChild(card);
                    });
                }
            });
            
            // FLIP Animations
            listsToRender.forEach(listInfo => {
                Array.from(listInfo.el.children).forEach(cardElement => {
                    const projectId = cardElement.dataset.id;
                    if (!projectId || cardElement.classList.contains('empty-list-message')) return;

                    const oldRect = firstPassPositions.get(projectId);
                    if (!oldRect) { // Entering
                        cardElement.classList.add('entering');
                        requestAnimationFrame(() => { 
                            cardElement.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                            cardElement.classList.remove('entering'); 
                            cardElement.addEventListener('transitionend', () => cardElement.style.transition = '', { once: true });
                        });
                    } else { // Moving
                        const newRect = cardElement.getBoundingClientRect();
                        const deltaX = oldRect.left - newRect.left;
                        const deltaY = oldRect.top - newRect.top;
                        if (deltaX !== 0 || deltaY !== 0) {
                            cardElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                            cardElement.style.transition = 'none'; 
                            requestAnimationFrame(() => { 
                                cardElement.style.transition = 'transform 0.35s cubic-bezier(0.25, 0.8, 0.25, 1)';
                                cardElement.style.transform = 'translate(0, 0)';
                                cardElement.addEventListener('transitionend', () => {
                                    cardElement.style.transform = ''; cardElement.style.transition = '';
                                }, { once: true });
                            });
                        }
                    }
                });
            });
            updateDashboard();
             // Restore scroll positions
            appData.projects.forEach(project => {
                if (project.ui_isExpanded) {
                    const projectCard = document.querySelector(`.quest-card[data-id="${project.id}"]`);
                    if (projectCard) {
                        const tasksContainerEl = projectCard.querySelector('.tasks-container');
                        if (tasksContainerEl && tasksContainerEl.classList.contains('expanded')) {
                            // Delay scroll restoration slightly to allow layout to settle after FLIP
                            setTimeout(() => { tasksContainerEl.scrollTop = project.ui_scrollPosition || 0; }, 50); 
                        }
                    }
                }
            });
        }
        
        function animateThenRemoveQuest(projectId) { // For deletion
            const cardElement = document.querySelector(`.quest-card[data-id="${projectId}"]`);
            if (cardElement) {
                cardElement.classList.add('exiting');
                cardElement.addEventListener('animationend', () => {
                    appData.projects = appData.projects.filter(p => p.id !== projectId);
                    saveData();
                    renderProjects(); // Re-render to adjust layout if needed
                }, { once: true });
            } else { // Fallback if card not found
                appData.projects = appData.projects.filter(p => p.id !== projectId);
                saveData();
                renderProjects();
            }
        }


        function createProjectCard(project) {
            // ... (CreateMode's createProjectCard, but with Goalio styling and new deadline countdown)
            const card = document.createElement('div');
            card.className = 'quest-card';
            card.dataset.id = project.id;
            if (project.isCompleted) card.classList.add('completed-quest');
            if (project.isArchived) card.classList.add('archived-quest');

            project.tasks = project.tasks || [];
            project.tasks.forEach(t => t.subtasks = t.subtasks || []);

            const totalVal = parseFloat(project.totalValue) || 0;
            const earnedVal = parseFloat(project.valueEarned) || 0;
            let progressPercent = totalVal > 0 ? (earnedVal / totalVal) * 100 : 0;
            if(project.isCompleted && project.tasks.length > 0) progressPercent = 100;


            const deadlineInfo = calculateQuestDaysLeft(project.deadline);
            if (deadlineInfo.isOverdue && !project.isCompleted) card.classList.add('is-overdue');
            
            let deadlineHtml = `
                <span class="quest-deadline-details">
                    <i class="fas fa-calendar-alt"></i> <span class="quest-deadline-text">${deadlineInfo.deadlineFormatted}</span>
                </span>`;
            if (deadlineInfo.countdownText && !project.isCompleted) {
                deadlineHtml += `
                <span class="quest-countdown ${deadlineInfo.isOverdue ? 'overdue' : ''} ${deadlineInfo.isToday ? 'today' : ''}">
                    &bull; <i class="fas fa-hourglass-half"></i> <span class="quest-countdown-text">${deadlineInfo.countdownText}</span>
                </span>`;
            }

            card.innerHTML = `
                <div class="quest-card-header">
                    <input type="checkbox" class="quest-complete-checkbox" ${project.isCompleted ? 'checked' : ''} title="Mark Quest Complete/Active" aria-label="Mark quest '${project.title}' as ${project.isCompleted ? 'active' : 'complete'}" ${project.isArchived ? 'disabled' : ''}>
                    <p class="quest-title-text" title="Edit Quest: ${project.title}">${project.title}</p>
                    <div class="quest-card-action-buttons">
                        <button class="toggle-tasks-button btn-icon-only" title="Toggle Tasks View" aria-label="Toggle tasks for quest '${project.title}'">
                            <i class="fas fa-chevron-${project.ui_isExpanded ? 'up' : 'down'}"></i>
                        </button>
                        <button class="priority-button btn-icon-only ${project.priority ? 'prioritized' : ''}" title="${project.priority ? 'Remove Priority' : 'Set Priority'}" aria-label="${project.priority ? 'Remove priority from' : 'Set priority for'} quest '${project.title}'" ${project.isArchived ? 'disabled' : ''}>
                            <i class="fas fa-star"></i>
                        </button>
                        <div class="quest-more-actions-container">
                            <button class="more-actions-button btn-icon-only" title="More Actions" aria-label="More actions for quest '${project.title}'">
                                <i class="fas fa-ellipsis-v"></i>
                            </button>
                            <div class="actions-dropdown">
                                <button class="action-edit-quest" data-id="${project.id}"><i class="fas fa-edit"></i> Edit</button>
                                ${project.isArchived
                                    ? `<button class="action-unarchive-quest" data-id="${project.id}"><i class="fas fa-folder-open"></i> Unarchive</button>`
                                    : `<button class="action-archive-quest" data-id="${project.id}"><i class="fas fa-archive"></i> Archive</button>`
                                }
                                <button class="action-delete-quest danger" data-id="${project.id}"><i class="fas fa-trash-alt"></i> Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="quest-card-meta">
                    ${deadlineHtml}
                    <span class="quest-value-display" style="margin-left: auto;"> <!-- Pushed to right -->
                        <i class="fas fa-coins"></i> $${earnedVal.toFixed(0)} / $${totalVal.toFixed(0)}
                    </span>
                </div>
                <div class="quest-progress-wrapper">
                    <div class="quest-progress-bar-container" title="Progress: ${progressPercent.toFixed(0)}%">
                        <div class="quest-progress-fill" style="width: ${Math.min(100, progressPercent).toFixed(0)}%;"></div>
                    </div>
                    <span class="quest-progress-value-text">${progressPercent.toFixed(0)}%</span>
                </div>
                <div class="tasks-container ${project.ui_isExpanded ? 'expanded' : ''}">
                    ${project.tasks.length > 0 ? project.tasks.map(task => createTaskElement(task, project.id, project.title, project.isArchived)).join('') : '<p style="font-size:0.85em; color: var(--text-light); text-align:center; padding:0.5rem 0;">No tasks defined for this quest.</p>'}
                </div>`;

            // Event listeners (same as CreateMode, but ensure selectors are correct)
            card.querySelector('.toggle-tasks-button').addEventListener('click', (e) => {
                e.stopPropagation();
                const projectToToggle = appData.projects.find(p => p.id === project.id);
                if (projectToToggle) {
                    const tasksContainerEl = card.querySelector('.tasks-container');
                    const isCurrentlyExpanded = tasksContainerEl.classList.contains('expanded');
                    if (isCurrentlyExpanded) projectToToggle.ui_scrollPosition = tasksContainerEl.scrollTop;
                    else projectToToggle.ui_scrollPosition = 0; // Reset if collapsing

                    projectToToggle.ui_isExpanded = !projectToToggle.ui_isExpanded;
                    tasksContainerEl.classList.toggle('expanded', projectToToggle.ui_isExpanded);
                    e.currentTarget.querySelector('i').className = `fas fa-chevron-${projectToToggle.ui_isExpanded ? 'up' : 'down'}`;
                    
                    if (projectToToggle.ui_isExpanded) { 
                         requestAnimationFrame(() => requestAnimationFrame(() => { tasksContainerEl.scrollTop = projectToToggle.ui_scrollPosition || 0; }));
                    }
                    saveData(); 
                }
            });
            const completeCheckbox = card.querySelector('.quest-complete-checkbox');
            if (completeCheckbox) completeCheckbox.addEventListener('change', (e) => toggleProjectComplete(project.id, e.target.checked));
            
            const priorityBtn = card.querySelector('.priority-button');
            if (priorityBtn) priorityBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleProjectPriority(project.id); });

            card.querySelector('.quest-title-text').addEventListener('click', () => openQuestModal(project.id));
            card.querySelectorAll('.task-checkbox').forEach(cb => cb.addEventListener('change', (e) => toggleTaskComplete(project.id, e.target.dataset.taskId, e.target.checked, e.target)));
            card.querySelectorAll('.subtask-checkbox').forEach(cb => cb.addEventListener('change', (e) => toggleSubtaskComplete(project.id, e.target.dataset.mainTaskId, e.target.dataset.subtaskId, e.target.checked, e.target)));

            const moreActionsBtn = card.querySelector('.more-actions-button');
            const actionsDropdown = card.querySelector('.actions-dropdown');
            moreActionsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.actions-dropdown').forEach(dd => { if (dd !== actionsDropdown) dd.style.display = 'none'; });
                actionsDropdown.style.display = actionsDropdown.style.display === 'none' ? 'block' : 'none';
            });
            card.querySelector('.action-edit-quest')?.addEventListener('click', () => { openQuestModal(project.id); actionsDropdown.style.display = 'none'; });
            card.querySelector('.action-archive-quest')?.addEventListener('click', () => { archiveProject(project.id); actionsDropdown.style.display = 'none'; });
            card.querySelector('.action-unarchive-quest')?.addEventListener('click', () => { unarchiveProject(project.id); actionsDropdown.style.display = 'none'; });
            card.querySelector('.action-delete-quest')?.addEventListener('click', () => { deleteProjectWithAnimation(project.id); actionsDropdown.style.display = 'none'; });


            return card;
        }

        function createTaskElement(task, projectId, projectTitle, isProjectArchived) { /* ... (CreateMode's, ensure classes match new CSS) ... */ 
            task.subtasks = task.subtasks || [];
            let valueDisplay = '';
            if (task.taskValue !== undefined && task.taskValue > 0 && task.subtasks.length === 0) { // Only show value if no subtasks
                 valueDisplay = `<span class="task-value-chip">$${(parseFloat(task.taskValue) || 0).toFixed(0)}</span>`;
            }
            return `
                <div class="task-item ${task.isCompleted ? 'completed' : ''}" data-task-id="${task.id}">
                    <input type="checkbox" class="task-checkbox" data-task-id="${task.id}" ${task.isCompleted ? 'checked' : ''} title="Complete task: ${task.description}" aria-label="Mark task '${task.description}' of quest '${projectTitle}' as ${task.isCompleted ? 'incomplete' : 'complete'}" ${isProjectArchived ? 'disabled' : ''}>
                    <span class="task-description">${task.description}</span>
                    ${valueDisplay}
                </div>
                ${task.subtasks.map(subtask => createSubtaskElement(subtask, task.id, projectId, projectTitle, task.description, isProjectArchived)).join('')}`;
        }
        function createSubtaskElement(subtask, mainTaskId, projectId, projectTitle, mainTaskDescription, isProjectArchived) { /* ... (CreateMode's, ensure classes match new CSS) ... */
             let valueDisplay = '';
             if (subtask.subtaskValue !== undefined && subtask.subtaskValue > 0) {
                 valueDisplay = `<span class="task-value-chip">$${(parseFloat(subtask.subtaskValue) || 0).toFixed(0)}</span>`;
             }
            return `
                <div class="subtask-item ${subtask.isCompleted ? 'completed' : ''}" data-subtask-id="${subtask.id}" data-main-task-id="${mainTaskId}">
                    <input type="checkbox" class="subtask-checkbox" data-main-task-id="${mainTaskId}" data-subtask-id="${subtask.id}" ${subtask.isCompleted ? 'checked' : ''} title="Complete subtask: ${subtask.description}" aria-label="Mark subtask '${subtask.description}' of task '${mainTaskDescription}' as ${subtask.isCompleted ? 'incomplete' : 'complete'}" ${isProjectArchived ? 'disabled' : ''}>
                    <span class="task-description">${subtask.description}</span>
                    ${valueDisplay}
                </div>`;
        }
        function distributeValueToTasks(project) { /* ... (CreateMode's distributeValueToTasks) ... */ 
            project.tasks = project.tasks || [];
            const mainTasksWithValuePotential = project.tasks.filter(task => (task.subtasks || []).length === 0);
            const subTasksWithValuePotential = project.tasks.reduce((acc, task) => acc.concat(task.subtasks || []), []);
            
            const totalVal = parseFloat(project.totalValue) || 0;
            let totalValueUnits = 0;

            project.tasks.forEach(task => {
                task.subtasks = task.subtasks || [];
                if (task.subtasks.length > 0) {
                    totalValueUnits += task.subtasks.length;
                } else {
                    totalValueUnits += 1; // Each main task without subtasks counts as 1 unit
                }
            });


            if (totalValueUnits === 0 || totalVal === 0) {
                project.tasks.forEach(task => { 
                    task.taskValue = 0; 
                    task.subtasks.forEach(sub => sub.subtaskValue = 0); 
                });
                return;
            }

            const valuePerUnit = totalVal / totalValueUnits;

            project.tasks.forEach(task => {
                if (task.subtasks.length > 0) {
                    task.taskValue = 0; // Main task value is sum of subtasks if they exist
                    task.subtasks.forEach(sub => sub.subtaskValue = valuePerUnit);
                } else {
                    task.taskValue = valuePerUnit;
                }
            });
        }
        
        function toggleProjectComplete(projectId, isBeingMarkedCompleted) { /* ... (CreateMode's logic) ... */
            const project = appData.projects.find(p => p.id === projectId);
            if (!project || project.isArchived) return;

            project.tasks = project.tasks || [];
            project.tasks.forEach(t => t.subtasks = t.subtasks || []);

            const oldCompletedState = project.isCompleted;
            project.isCompleted = isBeingMarkedCompleted;

            if (isBeingMarkedCompleted) {
                project.completionTimestamp = project.completionTimestamp || Date.now();
                project.valueEarned = parseFloat(project.totalValue) || 0;
                project.tasks.forEach(task => { 
                    task.isCompleted = true; 
                    task.completionTimestamp = task.completionTimestamp || Date.now(); 
                    task.subtasks.forEach(sub => {
                        sub.isCompleted = true;
                        sub.completionTimestamp = sub.completionTimestamp || Date.now();
                    }); 
                });
                if (!oldCompletedState) { 
                    showToast(`Quest "<strong>${project.title}</strong>" completed! +$${project.valueEarned.toFixed(0)} earned.`, 'success', 4000); 
                }
            } else { 
                project.completionTimestamp = null;
                // valueEarned will be recalculated by updateProjectCardDOM
                if (oldCompletedState) { 
                    showToast(`Quest "<strong>${project.title}</strong>" reactivated.`, 'info');
                }
            }
            updateProjectCardDOM(projectId, true);
        }
        function updateProjectCardDOM(projectId, forceRenderAll = false) { /* ... (CreateMode's logic, ensure it triggers renderProjects for FLIP on status change) ... */
            const project = appData.projects.find(p => p.id === projectId);
            if (!project) return;
            project.tasks = project.tasks || [];
            project.tasks.forEach(t => t.subtasks = t.subtasks || []);
            
            let newEarnedValue = 0;
            project.tasks.forEach(task => {
                if (task.subtasks.length > 0) {
                    task.subtasks.forEach(subtask => {
                        if (subtask.isCompleted) newEarnedValue += (parseFloat(subtask.subtaskValue) || 0);
                    });
                } else { 
                    if (task.isCompleted) newEarnedValue += (parseFloat(task.taskValue) || 0);
                }
            });
            project.valueEarned = Math.max(0, Math.min(newEarnedValue, parseFloat(project.totalValue) || 0));

            const oldProjectCompletedState = project.isCompleted;
            const allTasksEffectivelyDone = project.tasks.length > 0 && project.tasks.every(task => {
                if (task.subtasks.length > 0) return task.subtasks.every(st => st.isCompleted);
                return task.isCompleted;
            });

            if (allTasksEffectivelyDone && !project.isCompleted && !project.isArchived) {
                project.isCompleted = true;
                project.completionTimestamp = project.completionTimestamp || Date.now();
                project.valueEarned = parseFloat(project.totalValue); 
                 if (!oldProjectCompletedState) showToast(`Quest "<strong>${project.title}</strong>" auto-completed!`, 'success', 4000);
            } else if (!allTasksEffectivelyDone && project.isCompleted && !project.isArchived) {
                project.isCompleted = false;
                project.completionTimestamp = null;
                if (oldProjectCompletedState) showToast(`Quest "<strong>${project.title}</strong>" reactivated (task incomplete).`, 'info');
            }
            
            if (forceRenderAll || oldProjectCompletedState !== project.isCompleted) {
                saveData(); renderProjects(); 
            } else { // Partial update if card exists and no major status change
                const projectCardElement = document.querySelector(`.quest-card[data-id="${projectId}"]`);
                if (projectCardElement) {
                    const valueDisplay = projectCardElement.querySelector('.quest-value-display');
                    if (valueDisplay) valueDisplay.innerHTML = `<i class="fas fa-coins"></i> $${project.valueEarned.toFixed(0)} / $${(parseFloat(project.totalValue) || 0).toFixed(0)}`;
                    
                    const totalVal = parseFloat(project.totalValue) || 0;
                    let progressPercent = totalVal > 0 ? (project.valueEarned / totalVal) * 100 : 0;
                    if(project.isCompleted && project.tasks.length > 0) progressPercent = 100;


                    const progressFill = projectCardElement.querySelector('.quest-progress-fill');
                    const progressText = projectCardElement.querySelector('.quest-progress-value-text');
                    if (progressFill) progressFill.style.width = `${Math.min(100, progressPercent).toFixed(0)}%`;
                    if (progressText) progressText.textContent = `${progressPercent.toFixed(0)}%`;
                    if (progressFill && progressFill.parentElement) progressFill.parentElement.title = `Progress: ${progressPercent.toFixed(0)}%`;

                    const mainCheckbox = projectCardElement.querySelector('.quest-complete-checkbox');
                    if (mainCheckbox && mainCheckbox.checked !== project.isCompleted) mainCheckbox.checked = project.isCompleted;
                    projectCardElement.classList.toggle('completed-quest', project.isCompleted);

                    const deadlineInfo = calculateQuestDaysLeft(project.deadline);
                    projectCardElement.classList.toggle('is-overdue', deadlineInfo.isOverdue && !project.isCompleted);
                    const deadlineTextEl = projectCardElement.querySelector('.quest-deadline-text');
                    if (deadlineTextEl) deadlineTextEl.textContent = deadlineInfo.deadlineFormatted;
                    const countdownTextEl = projectCardElement.querySelector('.quest-countdown-text');
                    if (countdownTextEl) countdownTextEl.textContent = deadlineInfo.countdownText;
                    const countdownContainerEl = projectCardElement.querySelector('.quest-countdown');
                    if(countdownContainerEl) {
                        countdownContainerEl.classList.toggle('overdue', deadlineInfo.isOverdue);
                        countdownContainerEl.classList.toggle('today', deadlineInfo.isToday);
                        countdownContainerEl.style.display = (deadlineInfo.countdownText && !project.isCompleted) ? 'flex' : 'none';
                    }
                }
                saveData(); updateDashboard(); 
            }
        }
        function toggleProjectPriority(projectId) { /* ... (CreateMode's) ... */ 
            const project = appData.projects.find(p => p.id === projectId);
            if (!project || project.isArchived) return; 
            project.priority = !project.priority;
            saveData(); renderProjects(); 
            if(project.priority) { showToast(`Quest "<strong>${project.title}</strong>" prioritized.`, 'info'); } 
            else { showToast(`Quest "<strong>${project.title}</strong>" unprioritized.`, 'info'); }
        }
        function toggleTaskComplete(projectId, taskId, isCompleted, checkboxElement) { /* ... (CreateMode's) ... */
            const project = appData.projects.find(p => p.id === projectId);
            if (!project || project.isArchived) return; 
            project.tasks = project.tasks || [];
            const task = project.tasks.find(t => t.id === taskId);
            if (!task) return;
            task.subtasks = task.subtasks || [];

            const wasTaskPreviouslyCompleted = task.isCompleted; 
            task.isCompleted = isCompleted;

            if (isCompleted && !wasTaskPreviouslyCompleted) task.completionTimestamp = task.completionTimestamp || Date.now();
            else if (!isCompleted) task.completionTimestamp = null;
            
            const taskItemElement = checkboxElement.closest('.task-item');
            if (taskItemElement) taskItemElement.classList.toggle('completed', isCompleted);

            let valueChangeForToast = 0;
            task.subtasks.forEach(sub => {
                const wasSubtaskPreviouslyCompleted = sub.isCompleted;
                sub.isCompleted = isCompleted; 
                if (isCompleted && !wasSubtaskPreviouslyCompleted) {
                    sub.completionTimestamp = sub.completionTimestamp || Date.now();
                    valueChangeForToast += (parseFloat(sub.subtaskValue) || 0);
                } else if (!isCompleted) sub.completionTimestamp = null;
                
                const subtaskItemElement = document.querySelector(`.subtask-item[data-subtask-id="${sub.id}"][data-main-task-id="${task.id}"]`);
                if (subtaskItemElement) {
                    subtaskItemElement.classList.toggle('completed', isCompleted);
                    const subtaskCheckbox = subtaskItemElement.querySelector('.subtask-checkbox');
                    if (subtaskCheckbox) subtaskCheckbox.checked = isCompleted;
                }
            });
            if (task.subtasks.length === 0 && isCompleted && !wasTaskPreviouslyCompleted) {
                 valueChangeForToast = parseFloat(task.taskValue) || 0;
            }
            if (isCompleted && !wasTaskPreviouslyCompleted) {
                const message = valueChangeForToast > 0 ? `Task "<strong>${task.description}</strong>" completed! +$${valueChangeForToast.toFixed(0)}` : `Task "<strong>${task.description}</strong>" completed!`;
                showToast(message, 'success');
            } else if (!isCompleted && wasTaskPreviouslyCompleted) {
                 showToast(`Task "<strong>${task.description}</strong>" un-checked.`, 'info');
            }
            updateProjectCardDOM(projectId); 
        }
        function toggleSubtaskComplete(projectId, mainTaskId, subtaskId, isCompleted, checkboxElement) { /* ... (CreateMode's) ... */
            const project = appData.projects.find(p => p.id === projectId);
            if (!project || project.isArchived) return; 
            project.tasks = project.tasks || [];
            const mainTask = project.tasks.find(t => t.id === mainTaskId);
            if (!mainTask) return;
            mainTask.subtasks = mainTask.subtasks || [];
            const subtask = mainTask.subtasks.find(s => s.id === subtaskId);
            if (!subtask) return;

            const wasSubtaskPreviouslyCompleted = subtask.isCompleted;
            subtask.isCompleted = isCompleted;

            if (isCompleted && !wasSubtaskPreviouslyCompleted) subtask.completionTimestamp = subtask.completionTimestamp || Date.now();
            else if (!isCompleted) subtask.completionTimestamp = null;
            
            const subtaskItemElement = checkboxElement.closest('.subtask-item');
            if (subtaskItemElement) subtaskItemElement.classList.toggle('completed', isCompleted);

            if (isCompleted && !wasSubtaskPreviouslyCompleted) {
                const subValue = parseFloat(subtask.subtaskValue) || 0;
                const message = subValue > 0 ? `Subtask "<strong>${subtask.description}</strong>" completed! +$${subValue.toFixed(0)}` : `Subtask "<strong>${subtask.description}</strong>" completed!`;
                showToast(message, 'success');
            } else if (!isCompleted && wasSubtaskPreviouslyCompleted) {
                showToast(`Subtask "<strong>${subtask.description}</strong>" un-checked.`, 'info');
            }

            const wasMainTaskPreviouslyCompleted = mainTask.isCompleted;
            if (mainTask.subtasks.length > 0) {
                const allSubtasksDone = mainTask.subtasks.every(s => s.isCompleted);
                if (allSubtasksDone && !wasMainTaskPreviouslyCompleted) {
                    mainTask.isCompleted = true; mainTask.completionTimestamp = mainTask.completionTimestamp || Date.now();
                    showToast(`Task "<strong>${mainTask.description}</strong>" completed! (All subtasks done)`, 'success');
                } else if (!allSubtasksDone && wasMainTaskPreviouslyCompleted) {
                    mainTask.isCompleted = false; mainTask.completionTimestamp = null;
                    showToast(`Task "<strong>${mainTask.description}</strong>" reactivated (subtask un-checked).`, 'info');
                } else mainTask.isCompleted = allSubtasksDone;

                const mainTaskItemElement = document.querySelector(`.task-item[data-task-id="${mainTask.id}"]`);
                if (mainTaskItemElement) {
                    mainTaskItemElement.classList.toggle('completed', mainTask.isCompleted);
                    const mainTaskCheckbox = mainTaskItemElement.querySelector('.task-checkbox');
                    if (mainTaskCheckbox) mainTaskCheckbox.checked = mainTask.isCompleted;
                }
            }
            updateProjectCardDOM(projectId); 
        }
        
        function deleteProjectWithAnimation(projectId) { // Modified to use animation
            const project = appData.projects.find(p => p.id === projectId);
            if (!project) return;
            showCustomConfirm(
                `Are you sure you want to PERMANENTLY DELETE the quest "<strong>${project.title}</strong>"? This cannot be undone.`,
                "Delete Quest",
                () => { 
                    animateThenRemoveQuest(projectId); // Use animated removal
                    showToast(`Quest "<strong>${project.title}</strong>" deleted.`, 'info');
                }
            );
        }
        function archiveProject(projectId) { /* ... (CreateMode's) ... */ 
            const project = appData.projects.find(p => p.id === projectId);
            if (!project) return;
            project.isArchived = true;
            saveData(); renderProjects();
            showToast(`Quest "<strong>${project.title}</strong>" archived.`, 'info');
        }
        function unarchiveProject(projectId) { /* ... (CreateMode's) ... */ 
            const project = appData.projects.find(p => p.id === projectId);
            if (!project) return;
            project.isArchived = false;
            saveData(); renderProjects();
            showToast(`Quest "<strong>${project.title}</strong>" unarchived.`, 'info');
        }

        const questModal = document.getElementById('questModal');
        const closeQuestModalBtn = document.getElementById('closeQuestModal');
        const cancelQuestModalBtn = document.getElementById('cancelQuestModalBtn'); // New cancel button in footer
        const addQuestHeaderBtn = document.getElementById('addQuestHeaderBtn');
        const saveQuestBtn = document.getElementById('saveQuestBtn');
        const questModalTitleEl = document.getElementById('questModalTitle');
        const questIdInput = document.getElementById('questId');
        const questTitleInput = document.getElementById('questTitle');
        const questDeadlineInput = document.getElementById('questDeadline');
        const questValueInput = document.getElementById('questValueInput');
        const questTemplateSelect = document.getElementById('questTemplateSelect');
        const modalTasksContainer = document.getElementById('modalTasksContainer');
        const addModalMainTaskBtn = document.getElementById('addModalMainTaskBtn');

        function openQuestModal(projectId = null) { /* ... (CreateMode's) ... */ 
            populateTemplateSelect(questTemplateSelect);
            modalTasksContainer.innerHTML = ''; 
            if (projectId) {
                const project = appData.projects.find(p => p.id === projectId);
                project.tasks = project.tasks || [];
                questModalTitleEl.innerHTML = `<i class="fas fa-edit" style="margin-right:0.5rem;"></i>Edit Quest`;
                questIdInput.value = project.id;
                questTitleInput.value = project.title;
                questDeadlineInput.value = project.deadline || '';
                questValueInput.value = project.totalValue;
                project.tasks.forEach(taskData => {
                    taskData.subtasks = taskData.subtasks || [];
                    addModalTaskEditor(taskData);
                });
            } else {
                questModalTitleEl.innerHTML = `<i class="fas fa-plus-circle" style="margin-right:0.5rem;"></i>Start New Quest`;
                questIdInput.value = '';
                questTitleInput.value = '';
                questDeadlineInput.value = getTodayString(); 
                questValueInput.value = '100'; 
                const defaultTemplateId = questTemplateSelect.value;
                if (defaultTemplateId) {
                    const template = appData.templates.find(t => t.id === defaultTemplateId);
                    if (template) (template.tasks || []).forEach(taskData => addModalTaskEditor({ 
                         ...taskData, id: generateId(), isCompleted: false, completionTimestamp: null,
                         subtasks: (taskData.subtasks || []).map(st => ({...st, id: generateId(), isCompleted: false, completionTimestamp: null, subtaskValue: 0}))
                    }));
                } else { addModalTaskEditor(); } 
            }
            questModal.style.display = 'flex'; // Use flex for centering
            questTitleInput.focus();
        }
        questTemplateSelect.addEventListener('change', () => { /* ... (CreateMode's) ... */
            if (!questIdInput.value) { 
                modalTasksContainer.innerHTML = ''; 
                const templateId = questTemplateSelect.value;
                if (templateId) {
                    const template = appData.templates.find(t => t.id === templateId);
                    if (template) (template.tasks || []).forEach(taskData => addModalTaskEditor({ 
                        ...taskData, id: generateId(), isCompleted: false, completionTimestamp: null,
                        subtasks: (taskData.subtasks || []).map(st => ({...st, id: generateId(), isCompleted: false, completionTimestamp: null, subtaskValue: 0})) 
                    }));
                } else { addModalTaskEditor(); } 
            }
        });
        function addModalTaskEditor(taskData = null) { /* ... (CreateMode's, ensure classes and icons match new CSS/FA) ... */ 
            const taskId = taskData ? taskData.id : generateId();
            const taskDesc = taskData ? taskData.description : '';
            const taskDiv = document.createElement('div');
            taskDiv.className = 'task-editor-item';
            taskDiv.dataset.taskId = taskId; 
            taskDiv.innerHTML = `
                <div class="task-editor-header">
                    <input type="text" class="modal-task-desc" value="${taskDesc}" placeholder="Main Task Description">
                    <button type="button" class="remove-modal-task-btn btn-icon-only danger" title="Remove This Task" aria-label="Remove This Task"><i class="fas fa-trash-alt"></i></button>
                    <button type="button" class="add-modal-subtask-btn btn-icon-only" title="Add Subtask to This Task" aria-label="Add Subtask to This Task"><i class="fas fa-plus-circle"></i></button>
                </div>
                <div class="modal-subtasks-list" style="padding-top: 5px;"></div>`; // padding for visual separation
            modalTasksContainer.appendChild(taskDiv);
            if (taskData && taskData.subtasks) {
                taskData.subtasks = taskData.subtasks || [];
                taskData.subtasks.forEach(subtaskData => addModalSubtaskEditor(taskDiv.querySelector('.modal-subtasks-list'), subtaskData));
            }
            taskDiv.querySelector('.remove-modal-task-btn').onclick = () => taskDiv.remove();
            taskDiv.querySelector('.add-modal-subtask-btn').onclick = () => addModalSubtaskEditor(taskDiv.querySelector('.modal-subtasks-list'));
        }
        function addModalSubtaskEditor(parentList, subtaskData = null) { /* ... (CreateMode's) ... */ 
            const subtaskId = subtaskData ? subtaskData.id : generateId();
            const subtaskDesc = subtaskData ? subtaskData.description : '';
            const subtaskDiv = document.createElement('div');
            subtaskDiv.className = 'subtask-editor-item';
            subtaskDiv.dataset.subtaskId = subtaskId; 
            subtaskDiv.innerHTML = `
                <input type="text" class="modal-subtask-desc" value="${subtaskDesc}" placeholder="Subtask Description">
                <button type="button" class="remove-modal-subtask-btn btn-icon-only danger" title="Remove This Subtask" aria-label="Remove This Subtask"><i class="fas fa-trash-alt"></i></button>`;
            parentList.appendChild(subtaskDiv);
            subtaskDiv.querySelector('.remove-modal-subtask-btn').onclick = () => subtaskDiv.remove();
        }

        addModalMainTaskBtn.addEventListener('click', () => addModalTaskEditor());
        closeQuestModalBtn.addEventListener('click', () => questModal.style.display = 'none');
        cancelQuestModalBtn.addEventListener('click', () => questModal.style.display = 'none'); // New cancel button
        addQuestHeaderBtn.addEventListener('click', () => openQuestModal());

        saveQuestBtn.addEventListener('click', () => { /* ... (CreateMode's, ensure IDs from modal tasks are preserved if editing) ... */ 
            const id = questIdInput.value || generateId();
            const title = questTitleInput.value.trim();
            const deadline = questDeadlineInput.value; 
            const totalValue = parseFloat(questValueInput.value) || 0;
            if (!title) { showToast('Quest Title is required.', 'warning'); questTitleInput.focus(); return; }

            const tasksFromModal = [];
            document.querySelectorAll('#modalTasksContainer .task-editor-item').forEach(taskDiv => {
                const taskDesc = taskDiv.querySelector('.modal-task-desc').value.trim();
                if (taskDesc) {
                    const mainTask = {
                        id: taskDiv.dataset.taskId || generateId(), // Ensure new tasks get an ID
                        description: taskDesc, isCompleted: false, completionTimestamp: null, taskValue: 0, subtasks: [] 
                    };
                    taskDiv.querySelectorAll('.subtask-editor-item').forEach(subtaskDiv => {
                        const subtaskDesc = subtaskDiv.querySelector('.modal-subtask-desc').value.trim();
                        if (subtaskDesc) mainTask.subtasks.push({ 
                            id: subtaskDiv.dataset.subtaskId || generateId(), // Ensure new subtasks get an ID
                            description: subtaskDesc, isCompleted: false, completionTimestamp: null, subtaskValue: 0 
                        });
                    });
                    tasksFromModal.push(mainTask);
                }
            });
            
            const existingProject = appData.projects.find(p => p.id === id);
            if (existingProject) { 
                existingProject.title = title; existingProject.deadline = deadline; existingProject.totalValue = totalValue;
                const oldTasksMap = new Map((existingProject.tasks || []).map(t => [t.id, t]));
                
                tasksFromModal.forEach(newTask => {
                    newTask.subtasks = newTask.subtasks || [];
                    const oldTask = oldTasksMap.get(newTask.id);
                    if (oldTask) { // Preserve completion state for existing tasks/subtasks
                        newTask.isCompleted = oldTask.isCompleted; 
                        newTask.completionTimestamp = oldTask.completionTimestamp;
                        const oldSubtasksMap = new Map((oldTask.subtasks || []).map(st => [st.id, st]));
                        newTask.subtasks.forEach(newSubtask => {
                             const oldSubtask = oldSubtasksMap.get(newSubtask.id);
                             if(oldSubtask) {
                                 newSubtask.isCompleted = oldSubtask.isCompleted;
                                 newSubtask.completionTimestamp = oldSubtask.completionTimestamp;
                             }
                        });
                    }
                });
                existingProject.tasks = tasksFromModal;
                distributeValueToTasks(existingProject); 
                updateProjectCardDOM(existingProject.id, true); 
                showToast(`Quest "<strong>${existingProject.title}</strong>" updated.`, 'info');
            } else { 
                const newProject = {
                    id, title, deadline, totalValue, valueEarned: 0, isCompleted: false, 
                    completionTimestamp: null, priority: false, tasks: tasksFromModal, 
                    ui_isExpanded: true, ui_scrollPosition: 0, isArchived: false, creationTimestamp: Date.now()
                };
                distributeValueToTasks(newProject); 
                appData.projects.push(newProject);
                saveData(); renderProjects(); 
                showToast(`Quest "<strong>${newProject.title}</strong>" started.`, 'success');
            }
            questModal.style.display = 'none';
        });

        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsModalBtn = document.getElementById('closeSettingsModal');
        const settingsHeaderBtn = document.getElementById('settingsHeaderBtn');
        const templateIdInput = document.getElementById('templateId');
        const templateNameInput = document.getElementById('templateName');
        const templateTasksContainer = document.getElementById('templateTasksContainer');
        const addTemplateMainTaskBtn = document.getElementById('addTemplateMainTaskBtn');
        const saveTemplateBtn = document.getElementById('saveTemplateBtn');
        const newTemplateBtn = document.getElementById('newTemplateBtn');
        const templateListDiv = document.getElementById('templateList');

        settingsHeaderBtn.addEventListener('click', () => { /* ... (CreateMode's) ... */ 
            loadTemplateEditor(); renderTemplateList(); settingsModal.style.display = 'flex'; templateNameInput.focus();
        });
        closeSettingsModalBtn.addEventListener('click', () => settingsModal.style.display = 'none');
        document.getElementById('goToSettingsFromNotification').addEventListener('click', () => { /* ... (CreateMode's) ... */ 
            settingsModal.style.display = 'flex'; loadTemplateEditor(); renderTemplateList(); templateNameInput.focus();
        });

        function loadTemplateEditor(templateId = null) { /* ... (CreateMode's) ... */ 
            templateTasksContainer.innerHTML = '';
            if (templateId) {
                const template = appData.templates.find(t => t.id === templateId);
                if (template) { 
                    template.tasks = template.tasks || [];
                    templateIdInput.value = template.id; 
                    templateNameInput.value = template.name; 
                    template.tasks.forEach(taskData => {
                        taskData.subtasks = taskData.subtasks || [];
                        addTemplateTaskEditor(taskData);
                    });
                }
            } else { templateIdInput.value = ''; templateNameInput.value = ''; addTemplateTaskEditor(); }
            templateNameInput.focus();
        }
        function addTemplateTaskEditor(taskData = null) { /* ... (CreateMode's, ensure classes and icons match new CSS/FA) ... */ 
            const taskDesc = taskData ? taskData.description : '';
            const taskDiv = document.createElement('div');
            taskDiv.className = 'task-editor-item'; // Re-use modal task editor style
            taskDiv.innerHTML = `
                <div class="task-editor-header">
                    <input type="text" class="template-task-desc" value="${taskDesc}" placeholder="Main Task Description">
                    <button type="button" class="remove-template-task-btn btn-icon-only danger" title="Remove This Task"><i class="fas fa-trash-alt"></i></button>
                    <button type="button" class="add-template-subtask-btn btn-icon-only" title="Add Subtask"><i class="fas fa-plus-circle"></i></button>
                </div>
                <div class="template-subtasks-list" style="padding-top: 5px;"></div>`;
            templateTasksContainer.appendChild(taskDiv);
            if (taskData && taskData.subtasks) {
                taskData.subtasks = taskData.subtasks || [];
                taskData.subtasks.forEach(subtaskData => addTemplateSubtaskEditor(taskDiv.querySelector('.template-subtasks-list'), subtaskData));
            }
            taskDiv.querySelector('.remove-template-task-btn').onclick = () => taskDiv.remove();
            taskDiv.querySelector('.add-template-subtask-btn').onclick = () => addTemplateSubtaskEditor(taskDiv.querySelector('.template-subtasks-list'));
        }
        function addTemplateSubtaskEditor(parentList, subtaskData = null) { /* ... (CreateMode's) ... */
            const subtaskDesc = subtaskData ? subtaskData.description : '';
            const subtaskDiv = document.createElement('div');
            subtaskDiv.className = 'subtask-editor-item'; // Re-use modal subtask editor style
            subtaskDiv.innerHTML = `
                <input type="text" class="template-subtask-desc" value="${subtaskDesc}" placeholder="Subtask Description">
                <button type="button" class="remove-template-subtask-btn btn-icon-only danger" title="Remove This Subtask"><i class="fas fa-trash-alt"></i></button>`;
            parentList.appendChild(subtaskDiv);
            subtaskDiv.querySelector('.remove-template-subtask-btn').onclick = () => subtaskDiv.remove();
        }

        addTemplateMainTaskBtn.addEventListener('click', () => addTemplateTaskEditor());
        newTemplateBtn.addEventListener('click', () => loadTemplateEditor()); 
        saveTemplateBtn.addEventListener('click', () => { /* ... (CreateMode's) ... */ 
            const id = templateIdInput.value || generateId(); 
            const name = templateNameInput.value.trim();
            if (!name) { showToast('Template Name is required.', 'warning'); templateNameInput.focus(); return; }
            const tasks = [];
            document.querySelectorAll('#templateTasksContainer .task-editor-item').forEach(taskDiv => {
                const taskDesc = taskDiv.querySelector('.template-task-desc').value.trim();
                if (taskDesc) {
                    const mainTask = { description: taskDesc, subtasks: [] }; 
                    taskDiv.querySelectorAll('.subtask-editor-item').forEach(subtaskDiv => {
                        const subtaskDesc = subtaskDiv.querySelector('.template-subtask-desc').value.trim();
                        if (subtaskDesc) mainTask.subtasks.push({ description: subtaskDesc });
                    });
                    tasks.push(mainTask);
                }
            });
            const existingIndex = appData.templates.findIndex(t => t.id === id);
            if (existingIndex > -1) {
                appData.templates[existingIndex].name = name; appData.templates[existingIndex].tasks = tasks;
                showToast(`Template "<strong>${name}</strong>" updated.`, 'success');
            } else {
                const isFirstTemplate = appData.templates.length === 0;
                appData.templates.push({ id, name, tasks, isDefault: isFirstTemplate });
                showToast(`Template "<strong>${name}</strong>" saved.`, 'success');
            }
            saveData(); renderTemplateList(); loadTemplateEditor(id); 
        });

        function renderTemplateList() { /* ... (CreateMode's, ensure classes and icons match new CSS/FA) ... */ 
            templateListDiv.innerHTML = '';
            if (appData.templates.length === 0) { templateListDiv.innerHTML = '<p style="color: var(--text-light); font-style: italic;">No templates. Create one!</p>'; return; }
            appData.templates.forEach(template => {
                const item = document.createElement('div');
                item.className = 'template-item';
                if (template.isDefault) item.classList.add('default-template');
                item.innerHTML = `
                    <span>${template.name} ${template.isDefault ? '<strong style="color: var(--star-important-color);">(Default)</strong>' : ''}</span>
                    <div class="template-actions">
                        <button class="edit-template-btn btn-modal-utility" data-id="${template.id}" title="Edit ${template.name} template"><i class="fas fa-edit"></i> Edit</button>
                        ${!template.isDefault ? `<button class="set-default-template-btn btn-modal-utility" data-id="${template.id}" title="Set ${template.name} as Default Template" style="background-color:var(--star-important-color);color:var(--text-color);border-color:#f59e0b;"><i class="fas fa-star"></i> Set Default</button>` : ''}
                        <button class="delete-template-btn btn-icon-only danger" data-id="${template.id}" title="Delete ${template.name} template"><i class="fas fa-trash-alt"></i></button>
                    </div>`; // Used btn-modal-utility for edit/default, btn-icon-only for delete
                templateListDiv.appendChild(item);
            });
            templateListDiv.querySelectorAll('.edit-template-btn').forEach(btn => btn.onclick = () => loadTemplateEditor(btn.dataset.id));
            templateListDiv.querySelectorAll('.delete-template-btn').forEach(btn => btn.onclick = () => deleteTemplate(btn.dataset.id));
            templateListDiv.querySelectorAll('.set-default-template-btn').forEach(btn => btn.onclick = () => setDefaultTemplate(btn.dataset.id));
        }
        function deleteTemplate(templateId) { /* ... (CreateMode's) ... */
            const templateToDelete = appData.templates.find(t => t.id === templateId);
            if (!templateToDelete) return;
            if (templateToDelete.isDefault && appData.templates.length <= 1) { showToast("Cannot delete the only default template.", 'warning', 4000); return; }
            if (templateToDelete.isDefault && appData.templates.length > 1) { showToast("Cannot delete active default. Change default first.", 'warning', 4000); return; }
            showCustomConfirm(
                `Are you sure you want to delete the template "<strong>${templateToDelete.name}</strong>"?`, "Delete Template",
                () => { 
                    const name = templateToDelete.name; appData.templates = appData.templates.filter(t => t.id !== templateId);
                    if (appData.templates.length > 0 && !appData.templates.some(t => t.isDefault)) appData.templates[0].isDefault = true; 
                    saveData(); renderTemplateList(); loadTemplateEditor(); 
                    showToast(`Template "<strong>${name}</strong>" deleted.`, 'info');
                }
            );
        }
        function setDefaultTemplate(templateId) { /* ... (CreateMode's) ... */ 
            let name = '';
            appData.templates.forEach(t => { t.isDefault = (t.id === templateId); if (t.isDefault) name = t.name; });
            saveData(); renderTemplateList();
            if (name) { showToast(`Template "<strong>${name}</strong>" set as default.`, 'info'); }
        }
        function populateTemplateSelect(selectElement) { /* ... (CreateMode's) ... */
            selectElement.innerHTML = '<option value="">-- No Template --</option>';
            let defaultId = null;
            appData.templates.forEach(template => {
                const option = document.createElement('option');
                option.value = template.id; option.textContent = template.name;
                if (template.isDefault) { option.selected = true; defaultId = template.id; }
                selectElement.appendChild(option);
            });
            if (defaultId) selectElement.value = defaultId;
            return defaultId;
        }

        const clearOldDataBtn = document.getElementById('clearOldDataBtn');
        const clearDataNotificationDiv = document.getElementById('clearDataNotification');
        function checkClearDataNotification() { /* ... (CreateMode's) ... */
            const today = new Date();
            if (today.getDate() > 7) { 
                const firstDayCurrentMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                const hasOld = appData.projects.some(p => p.isCompleted && p.completionTimestamp && new Date(p.completionTimestamp) < firstDayCurrentMonth);
                clearDataNotificationDiv.style.display = hasOld ? 'flex' : 'none';
            } else { clearDataNotificationDiv.style.display = 'none'; }
        }
        clearOldDataBtn.addEventListener('click', () => { /* ... (CreateMode's) ... */
            showCustomConfirm(
                'WARNING! Permanently DELETE old project data (completed BEFORE current month)? This action CANNOT BE UNDONE. Are you sure?', "Clear Old Project Data",
                () => { 
                    const firstDayCurrentMonth = new Date(); firstDayCurrentMonth.setDate(1); firstDayCurrentMonth.setHours(0,0,0,0);
                    const initialCount = appData.projects.length;
                    appData.projects = appData.projects.filter(p => !(p.isCompleted && p.completionTimestamp && new Date(p.completionTimestamp) < firstDayCurrentMonth));
                    const cleared = initialCount - appData.projects.length;
                    saveData(); renderProjects(); 
                    showToast(`${cleared} old project(s) cleared.`, 'success', 4000);
                    checkClearDataNotification(); settingsModal.style.display = 'none'; 
                }
            );
        });

        window.addEventListener('DOMContentLoaded', () => {
            // Move original dashboard items
            const dashboardHost = document.getElementById('dashboardMetricsHost');
            const originalDashboardSource = document.getElementById('originalDashboardSource');
            Array.from(originalDashboardSource.children).forEach(child => dashboardHost.appendChild(child.cloneNode(true)));
            originalDashboardSource.remove(); // Remove the now-empty source


            loadData(); 
            initCustomConfirmModal(); 
            
            toggleInactiveSectionsBtn = document.getElementById('toggleInactiveSectionsBtn');
            inactiveSectionsToggleIcon = document.getElementById('inactiveSectionsToggleIcon');
            inactiveSectionsToggleText = document.getElementById('inactiveSectionsToggleText');
            completedSectionContainer = document.getElementById('completedSectionContainer');
            archivedSectionContainer = document.getElementById('archivedSectionContainer');
            
            initInactiveSectionsToggle(); 
            
            updateNotices();
            renderWeekCalendar(currentCalendarDate);
            // renderProjects(); // Called by initInactiveSectionsToggle
            checkClearDataNotification(); 

            document.addEventListener('click', function(event) {
                document.querySelectorAll('.actions-dropdown').forEach(dd => {
                    if (!dd.contains(event.target) && !(dd.previousElementSibling && dd.previousElementSibling.contains(event.target))) {
                         dd.style.display = 'none';
                    }
                });
                if (event.target == questModal) questModal.style.display = "none";
                if (event.target == settingsModal) settingsModal.style.display = "none";
                if (event.target == customConfirmModal && customConfirmModal.style.display === "flex") customConfirmModal.style.display = "none";
            });
            document.addEventListener('keydown', function(event) {
                if (event.key === "Escape" || event.key === "Esc") {
                    if (questModal.style.display === 'flex') questModal.style.display = "none";
                    if (settingsModal.style.display === 'flex') settingsModal.style.display = "none";
                    if (customConfirmModal.style.display === 'flex') customConfirmModal.style.display = "none";
                    document.querySelectorAll('.actions-dropdown').forEach(dd => dd.style.display = 'none');
                }
            });

            const toggleCompletedListBtn = document.getElementById('toggleCompletedListBtn');
            const completedQuestsListWrapper = document.getElementById('completedQuestsListWrapper');
            const completedQuestsList = document.getElementById('completedQuestsList'); // Assuming this is the direct child for quests
            let isCompletedListExpanded = false; 
            if (toggleCompletedListBtn && completedQuestsListWrapper) {
                completedQuestsListWrapper.classList.remove('expanded'); 
                toggleCompletedListBtn.querySelector('i').className = 'fas fa-chevron-down';
                toggleCompletedListBtn.addEventListener('click', () => {
                    isCompletedListExpanded = !isCompletedListExpanded;
                    completedQuestsListWrapper.classList.toggle('expanded', isCompletedListExpanded);
                    toggleCompletedListBtn.querySelector('i').className = isCompletedListExpanded ? 'fas fa-chevron-up' : 'fas fa-chevron-down';
                    if (isCompletedListExpanded && inactiveSectionsVisible && completedQuestsList.children.length === 0 && !completedQuestsList.querySelector('.empty-list-message')) {
                        completedQuestsList.innerHTML = '<p class="empty-list-message">No quests completed this month yet.</p>';
                    } else if (!isCompletedListExpanded && completedQuestsList.querySelector('.empty-list-message')) {
                         // Don't remove if not expanded, renderProjects will handle it if visible
                    } else if (isCompletedListExpanded && completedQuestsList.querySelector('.empty-list-message') && completedQuestsList.children.length > 1) {
                         completedQuestsList.querySelector('.empty-list-message').remove(); // Remove if items got added
                    }
                });
            }

            const toggleArchivedListBtn = document.getElementById('toggleArchivedListBtn');
            const archivedQuestsListWrapper = document.getElementById('archivedQuestsListWrapper');
            const archivedQuestsList = document.getElementById('archivedQuestsList');
            let isArchivedListExpanded = false; 
            if (toggleArchivedListBtn && archivedQuestsListWrapper) {
                archivedQuestsListWrapper.classList.remove('expanded');
                toggleArchivedListBtn.querySelector('i').className = 'fas fa-chevron-down';
                toggleArchivedListBtn.addEventListener('click', () => {
                    isArchivedListExpanded = !isArchivedListExpanded;
                    archivedQuestsListWrapper.classList.toggle('expanded', isArchivedListExpanded);
                    toggleArchivedListBtn.querySelector('i').className = isArchivedListExpanded ? 'fas fa-chevron-up' : 'fas fa-chevron-down';
                     if (isArchivedListExpanded && inactiveSectionsVisible && archivedQuestsList.children.length === 0 && !archivedQuestsList.querySelector('.empty-list-message')) {
                        archivedQuestsList.innerHTML = '<p class="empty-list-message">No archived quests.</p>';
                    } else if (!isArchivedListExpanded && archivedQuestsList.querySelector('.empty-list-message')) {
                        // Don't remove if not expanded
                    } else if (isArchivedListExpanded && archivedQuestsList.querySelector('.empty-list-message') && archivedQuestsList.children.length > 1) {
                        archivedQuestsList.querySelector('.empty-list-message').remove();
                    }
                });
            }
        });

        window.addEventListener('beforeunload', () => { /* ... (CreateMode's) ... */ 
            appData.projects.forEach(project => {
                if (project.ui_isExpanded) {
                    const projectCard = document.querySelector(`.quest-card[data-id="${project.id}"]`);
                    if (projectCard) {
                        const tasksContainerEl = projectCard.querySelector('.tasks-container');
                        if (tasksContainerEl) project.ui_scrollPosition = tasksContainerEl.scrollTop;
                    }
                }
            });
            saveData(); 
        });
        
        // PWA Service Worker Registration (from Goalio)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js') // Assuming sw.js for CreateMode is desired
                    .then(reg => console.log('Service Worker registered.', reg.scope))
                    .catch(err => console.log('Service Worker registration failed:', err));
            });
        }
    </script>
</body>
</html>
